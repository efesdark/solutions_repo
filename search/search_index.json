{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion, while seemingly simple, provides a rich framework for exploring fundamental principles of physics. The problem at hand is straightforward: analyze how the range of a projectile depends on its angle of projection. Despite its simplicity, the topic involves complex relationships governed by both linear and quadratic equations, making it an insightful subject of study. A key factor that makes this investigation compelling is the number of free parameters involved in projectile motion equations, such as initial velocity, gravitational acceleration, and launch height. These parameters contribute to a diverse set of solutions that model real-world scenarios, from the trajectory of a soccer ball to the flight path of a missile. Task 1. Theoretical Foundation To analyze the range as a function of the angle of projection, we start by deriving the governing equations from fundamental principles of kinematics and dynamics. The motion of a projectile in the absence of air resistance follows Newton\u2019s second law: Equations of Motion: Horizontal displacement: $$ x = v_0 \\cos(\\theta) t $$ Vertical displacement: $$ y = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2 $$ Solving these equations yields the total time of flight \\( T \\) : $$ T = \\frac{2v_0 \\sin(\\theta)}{g} $$ Substituting into the horizontal displacement equation, we obtain the range \\( R \\) : $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ This equation shows that the range depends on the square of the initial velocity and the sine of twice the projection angle. 2. Analysis of the Range The range \\( R \\) is maximized when \\( \\sin(2\\theta) \\) reaches its maximum value (1), which occurs at \\( 2\\theta = 90^\\circ \\) , or \\( \\theta = 45^\\circ \\) . Increasing the initial velocity \\( v_0 \\) increases the range quadratically. A higher gravitational acceleration \\( g \\) reduces the range. For non-zero launch height, the equation for \\( R \\) becomes more complex, requiring further analysis. 3. Practical Applications Sports: Understanding how the angle influences projectile range helps optimize techniques in soccer, basketball, and javelin throwing. Engineering: In artillery and missile technology, precise control over launch angles is essential for maximizing impact range. Space Exploration: The principles of projectile motion extend to orbital mechanics and spacecraft trajectory planning. 4. Implementation To further analyze the range as a function of the projection angle, a computational tool can be developed: - Algorithm: Implement numerical simulations in Python or MATLAB to visualize projectile motion under varying conditions. - Graphical Representation: Generate plots of range versus launch angle to observe the dependency. - Advanced Considerations: Extend the model to include air resistance, variable wind conditions, and non-flat terrain. Conclusion The study of projectile motion offers valuable insights into both theoretical physics and practical applications. By understanding the mathematical framework and leveraging computational tools, we can develop a deeper appreciation of how varying initial conditions affect a projectile\u2019s trajectory. Future work may involve refining the model with real-world complexities such as air resistance and varying gravitational fields. Interactive Simulation Click to interact with parameters Initial Velocity (m/s): 20 Gravity (m/s\u00b2): 9.81 Launch Height (m): 0 (function() { // Calculation and plotting logic function calculateRange(theta, v0, g, h) { const thetaRad = theta * Math.PI / 180; const sinTheta = Math.sin(thetaRad); const cosTheta = Math.cos(thetaRad); const discriminant = (v0*sinTheta)**2 + 2*g*h; if(discriminant < 0) return 0; const t = (v0*sinTheta + Math.sqrt(discriminant))/g; return v0*cosTheta * t; } function updatePlot() { const v0 = parseFloat(document.getElementById('v0').value); const g = parseFloat(document.getElementById('gravity').value); const h = parseFloat(document.getElementById('height').value); const angles = Array.from({length: 90}, (_, i) => i); const ranges = angles.map(angle => calculateRange(angle, v0, g, h)); Plotly.newPlot('plotly-chart', [{ x: angles, y: ranges, type: 'scatter', mode: 'lines+markers' }], { title: `Range vs. Launch Angle (v\u2080=${v0}m/s, g=${g}m/s\u00b2, h=${h}m)`, xaxis: {title: 'Launch Angle (degrees)'}, yaxis: {title: 'Range (m)'} }); } // Event listeners document.querySelectorAll('input[type=\"range\"]').forEach(input => { input.addEventListener('input', function() { document.getElementById(this.id + 'Value').textContent = this.value; updatePlot(); }); }); // Initial plot updatePlot(); })();","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"Investigating the Range as a Function of the Angle of Projection","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, while seemingly simple, provides a rich framework for exploring fundamental principles of physics. The problem at hand is straightforward: analyze how the range of a projectile depends on its angle of projection. Despite its simplicity, the topic involves complex relationships governed by both linear and quadratic equations, making it an insightful subject of study. A key factor that makes this investigation compelling is the number of free parameters involved in projectile motion equations, such as initial velocity, gravitational acceleration, and launch height. These parameters contribute to a diverse set of solutions that model real-world scenarios, from the trajectory of a soccer ball to the flight path of a missile.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task","text":"","title":"Task"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"To analyze the range as a function of the angle of projection, we start by deriving the governing equations from fundamental principles of kinematics and dynamics. The motion of a projectile in the absence of air resistance follows Newton\u2019s second law: Equations of Motion: Horizontal displacement: $$ x = v_0 \\cos(\\theta) t $$ Vertical displacement: $$ y = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2 $$ Solving these equations yields the total time of flight \\( T \\) : $$ T = \\frac{2v_0 \\sin(\\theta)}{g} $$ Substituting into the horizontal displacement equation, we obtain the range \\( R \\) : $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ This equation shows that the range depends on the square of the initial velocity and the sine of twice the projection angle.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The range \\( R \\) is maximized when \\( \\sin(2\\theta) \\) reaches its maximum value (1), which occurs at \\( 2\\theta = 90^\\circ \\) , or \\( \\theta = 45^\\circ \\) . Increasing the initial velocity \\( v_0 \\) increases the range quadratically. A higher gravitational acceleration \\( g \\) reduces the range. For non-zero launch height, the equation for \\( R \\) becomes more complex, requiring further analysis.","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports: Understanding how the angle influences projectile range helps optimize techniques in soccer, basketball, and javelin throwing. Engineering: In artillery and missile technology, precise control over launch angles is essential for maximizing impact range. Space Exploration: The principles of projectile motion extend to orbital mechanics and spacecraft trajectory planning.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"To further analyze the range as a function of the projection angle, a computational tool can be developed: - Algorithm: Implement numerical simulations in Python or MATLAB to visualize projectile motion under varying conditions. - Graphical Representation: Generate plots of range versus launch angle to observe the dependency. - Advanced Considerations: Extend the model to include air resistance, variable wind conditions, and non-flat terrain.","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"The study of projectile motion offers valuable insights into both theoretical physics and practical applications. By understanding the mathematical framework and leveraging computational tools, we can develop a deeper appreciation of how varying initial conditions affect a projectile\u2019s trajectory. Future work may involve refining the model with real-world complexities such as air resistance and varying gravitational fields.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#interactive-simulation","text":"Click to interact with parameters Initial Velocity (m/s): 20 Gravity (m/s\u00b2): 9.81 Launch Height (m): 0 (function() { // Calculation and plotting logic function calculateRange(theta, v0, g, h) { const thetaRad = theta * Math.PI / 180; const sinTheta = Math.sin(thetaRad); const cosTheta = Math.cos(thetaRad); const discriminant = (v0*sinTheta)**2 + 2*g*h; if(discriminant < 0) return 0; const t = (v0*sinTheta + Math.sqrt(discriminant))/g; return v0*cosTheta * t; } function updatePlot() { const v0 = parseFloat(document.getElementById('v0').value); const g = parseFloat(document.getElementById('gravity').value); const h = parseFloat(document.getElementById('height').value); const angles = Array.from({length: 90}, (_, i) => i); const ranges = angles.map(angle => calculateRange(angle, v0, g, h)); Plotly.newPlot('plotly-chart', [{ x: angles, y: ranges, type: 'scatter', mode: 'lines+markers' }], { title: `Range vs. Launch Angle (v\u2080=${v0}m/s, g=${g}m/s\u00b2, h=${h}m)`, xaxis: {title: 'Launch Angle (degrees)'}, yaxis: {title: 'Range (m)'} }); } // Event listeners document.querySelectorAll('input[type=\"range\"]').forEach(input => { input.addEventListener('input', function() { document.getElementById(this.id + 'Value').textContent = this.value; updatePlot(); }); }); // Initial plot updatePlot(); })();","title":"Interactive Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum exemplifies complex dynamics emerging from the interplay of damping, restoring, and driving forces. This system exhibits phenomena ranging from resonance to chaos, making it fundamental for understanding oscillatory systems in engineering and physics. Theoretical Foundation Governing Equation The motion is described by: $$ \\frac{d^2\\theta}{dt^2} + \\frac{b}{m}\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = \\frac{F}{mL}\\cos(\\omega_d t) $$ Linearized form (small angles): $$ \\frac{d^2\\theta}{dt^2} + 2\\beta\\omega_0\\frac{d\\theta}{dt} + \\omega_0^2\\theta = \\frac{F}{mL}\\cos(\\omega_d t) $$ Resonance Condition Maximum energy transfer occurs when: $$ \\omega_d = \\sqrt{\\omega_0^2 - 2\\beta^2} $$ Dynamics Analysis Parameter Effect on System Damping (\u03b2) \u2191 Resonance peak broadens Driving Force (F) \u2191 Amplitude increases Frequency Ratio (\u03c9_d/\u03c9_0) Phase shifts occur Practical Applications Energy Harvesting: Tuning \u03c9_d to match \u03c9\u2080 for maximum power Structural Engineering: Avoiding resonance in bridges Biological Systems: Neural oscillations modeling Interactive Simulation Damping (\u03b2): Force (F): Frequency (\u03c9_d): (function() { const solvePendulum = (beta, F, omega_d, tmax=30) => { const dt = 0.05; const omega0 = 1.0; let theta = 0.1, omega = 0; const solution = []; for(let t=0; t<=tmax; t+=dt) { const acceleration = F*Math.cos(omega_d*t) - 2*beta*omega0*omega - omega0**2*Math.sin(theta); omega += acceleration * dt; theta += omega * dt; solution.push({ t: t.toFixed(2), theta: theta, omega: omega }); } return solution; }; function updatePlot() { const beta = parseFloat(document.getElementById('beta').value); const F = parseFloat(document.getElementById('force').value); const omega_d = parseFloat(document.getElementById('freq').value); const data = solvePendulum(beta, F, omega_d); const trace1 = { x: data.map(d => d.t), y: data.map(d => d.theta), name: 'Angular Displacement', type: 'scatter' }; const trace2 = { x: data.map(d => d.theta), y: data.map(d => d.omega), name: 'Phase Portrait', mode: 'lines', type: 'scatter' }; Plotly.newPlot('pendulumPlot', [trace1, trace2], { title: `Forced Damped Pendulum Dynamics<br>\u03b2=${beta}, F=${F}, \u03c9<sub>d</sub>=${omega_d}`, grid: {rows: 1, columns: 2}, xaxis1: {title: 'Time (s)'}, yaxis1: {title: '\u03b8 (rad)'}, xaxis2: {title: '\u03b8 (rad)'}, yaxis2: {title: 'd\u03b8/dt (rad/s)'} }); } document.querySelectorAll('input[type=\"range\"]').forEach(input => { input.addEventListener('input', updatePlot); }); updatePlot(); })();","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"Investigating the Dynamics of a Forced Damped Pendulum","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum exemplifies complex dynamics emerging from the interplay of damping, restoring, and driving forces. This system exhibits phenomena ranging from resonance to chaos, making it fundamental for understanding oscillatory systems in engineering and physics.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#theoretical-foundation","text":"","title":"Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The motion is described by: $$ \\frac{d^2\\theta}{dt^2} + \\frac{b}{m}\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = \\frac{F}{mL}\\cos(\\omega_d t) $$ Linearized form (small angles): $$ \\frac{d^2\\theta}{dt^2} + 2\\beta\\omega_0\\frac{d\\theta}{dt} + \\omega_0^2\\theta = \\frac{F}{mL}\\cos(\\omega_d t) $$","title":"Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-condition","text":"Maximum energy transfer occurs when: $$ \\omega_d = \\sqrt{\\omega_0^2 - 2\\beta^2} $$","title":"Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#dynamics-analysis","text":"Parameter Effect on System Damping (\u03b2) \u2191 Resonance peak broadens Driving Force (F) \u2191 Amplitude increases Frequency Ratio (\u03c9_d/\u03c9_0) Phase shifts occur","title":"Dynamics Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#practical-applications","text":"Energy Harvesting: Tuning \u03c9_d to match \u03c9\u2080 for maximum power Structural Engineering: Avoiding resonance in bridges Biological Systems: Neural oscillations modeling","title":"Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#interactive-simulation","text":"Damping (\u03b2): Force (F): Frequency (\u03c9_d): (function() { const solvePendulum = (beta, F, omega_d, tmax=30) => { const dt = 0.05; const omega0 = 1.0; let theta = 0.1, omega = 0; const solution = []; for(let t=0; t<=tmax; t+=dt) { const acceleration = F*Math.cos(omega_d*t) - 2*beta*omega0*omega - omega0**2*Math.sin(theta); omega += acceleration * dt; theta += omega * dt; solution.push({ t: t.toFixed(2), theta: theta, omega: omega }); } return solution; }; function updatePlot() { const beta = parseFloat(document.getElementById('beta').value); const F = parseFloat(document.getElementById('force').value); const omega_d = parseFloat(document.getElementById('freq').value); const data = solvePendulum(beta, F, omega_d); const trace1 = { x: data.map(d => d.t), y: data.map(d => d.theta), name: 'Angular Displacement', type: 'scatter' }; const trace2 = { x: data.map(d => d.theta), y: data.map(d => d.omega), name: 'Phase Portrait', mode: 'lines', type: 'scatter' }; Plotly.newPlot('pendulumPlot', [trace1, trace2], { title: `Forced Damped Pendulum Dynamics<br>\u03b2=${beta}, F=${F}, \u03c9<sub>d</sub>=${omega_d}`, grid: {rows: 1, columns: 2}, xaxis1: {title: 'Time (s)'}, yaxis1: {title: '\u03b8 (rad)'}, xaxis2: {title: '\u03b8 (rad)'}, yaxis2: {title: 'd\u03b8/dt (rad/s)'} }); } document.querySelectorAll('input[type=\"range\"]').forEach(input => { input.addEventListener('input', updatePlot); }); updatePlot(); })();","title":"Interactive Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Theoretical Foundation From Newton's Law of Gravitation and centripetal force equivalence: $$ \\frac{GMm}{r^2} = \\frac{mv^2}{r} $$ Substituting orbital velocity \\(v = \\frac{2\\pi r}{T}\\) , we derive: $$ T^2 = \\left(\\frac{4\\pi^2}{GM}\\right)r^3 $$ Astronomical Significance Application Implementation Exoplanet Detection Mass estimation via period analysis Satellite Engineering Geostationary orbit calculation Galactic Dynamics Dark matter distribution studies Interactive Simulation Orbital Radius (Earth Radii): 60 Central Mass (Earth Masses): 1 (function() { const G = 6.67430e-11; // Gravitational constant const earthMass = 5.972e24; // kg const earthRadius = 6.371e6; // meters function calculatePeriod(r, M) { return Math.sqrt((4 * Math.PI**2 * r**3) / (G * M)); } function updateSimulation() { const radius = parseFloat(document.getElementById('radius').value); const mass = parseFloat(document.getElementById('mass').value); // Convert to SI units const rSI = radius * earthRadius; const MSI = mass * earthMass; // Calculate orbital period const T = calculatePeriod(rSI, MSI); // Generate orbit path const theta = Array.from({length: 100}, (_, i) => i * 2 * Math.PI / 100); const x = radius * theta.map(t => Math.cos(t)); const y = radius * theta.map(t => Math.sin(t)); // Update orbit plot Plotly.newPlot('orbitPlot', [{ x: x, y: y, mode: 'lines', name: 'Orbit', line: {color: '#00ff88'} }, { x: [0], y: [0], mode: 'markers', marker: {size: 20, color: '#1e90ff'}, name: 'Central Body' }], { title: `Orbital Period: ${(T/3600).toFixed(2)} hours`, showlegend: false, aspectratio: {x: 1, y: 1} }); // Generate verification data const radii = Array.from({length: 50}, (_, i) => 2 + (i*2)); const periods = radii.map(r => calculatePeriod(r * earthRadius, MSI) / 3600 ); // Update law verification plot Plotly.newPlot('lawVerification', [{ x: radii.map(r => r**3), y: periods.map(t => t**2), mode: 'lines+markers', name: 'T\u00b2 vs r\u00b3' }], { title: 'Kepler\\'s Third Law Verification', xaxis: {title: 'Orbital Radius\u00b3 (R\u2295\u00b3)'}, yaxis: {title: 'Orbital Period\u00b2 (hours\u00b2)'} }); } // Add event listeners document.querySelectorAll('input[type=\"range\"]').forEach(input => { input.addEventListener('input', function() { document.getElementById(this.id + 'Value').textContent = this.value; updateSimulation(); }); }); // Initial render updateSimulation(); })(); Practical Applications Satellite Deployment $$ r_{geo} = \\left(\\frac{T^2GM}{4\\pi^2}\\right)^{1/3} $$ Used to calculate geostationary orbit at ~42,164 km from Earth center Exoplanet Characterization Radial velocity method uses period measurements to estimate: $$ M \\propto \\frac{r^3}{T^2} $$ Historical Navigation Ancient mariners used Moon orbital period (sidereal month = 27.3 days) for tidal predictions","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#theoretical-foundation","text":"From Newton's Law of Gravitation and centripetal force equivalence: $$ \\frac{GMm}{r^2} = \\frac{mv^2}{r} $$ Substituting orbital velocity \\(v = \\frac{2\\pi r}{T}\\) , we derive: $$ T^2 = \\left(\\frac{4\\pi^2}{GM}\\right)r^3 $$","title":"Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#astronomical-significance","text":"Application Implementation Exoplanet Detection Mass estimation via period analysis Satellite Engineering Geostationary orbit calculation Galactic Dynamics Dark matter distribution studies","title":"Astronomical Significance"},{"location":"1%20Physics/2%20Gravity/Problem_1/#interactive-simulation","text":"Orbital Radius (Earth Radii): 60 Central Mass (Earth Masses): 1 (function() { const G = 6.67430e-11; // Gravitational constant const earthMass = 5.972e24; // kg const earthRadius = 6.371e6; // meters function calculatePeriod(r, M) { return Math.sqrt((4 * Math.PI**2 * r**3) / (G * M)); } function updateSimulation() { const radius = parseFloat(document.getElementById('radius').value); const mass = parseFloat(document.getElementById('mass').value); // Convert to SI units const rSI = radius * earthRadius; const MSI = mass * earthMass; // Calculate orbital period const T = calculatePeriod(rSI, MSI); // Generate orbit path const theta = Array.from({length: 100}, (_, i) => i * 2 * Math.PI / 100); const x = radius * theta.map(t => Math.cos(t)); const y = radius * theta.map(t => Math.sin(t)); // Update orbit plot Plotly.newPlot('orbitPlot', [{ x: x, y: y, mode: 'lines', name: 'Orbit', line: {color: '#00ff88'} }, { x: [0], y: [0], mode: 'markers', marker: {size: 20, color: '#1e90ff'}, name: 'Central Body' }], { title: `Orbital Period: ${(T/3600).toFixed(2)} hours`, showlegend: false, aspectratio: {x: 1, y: 1} }); // Generate verification data const radii = Array.from({length: 50}, (_, i) => 2 + (i*2)); const periods = radii.map(r => calculatePeriod(r * earthRadius, MSI) / 3600 ); // Update law verification plot Plotly.newPlot('lawVerification', [{ x: radii.map(r => r**3), y: periods.map(t => t**2), mode: 'lines+markers', name: 'T\u00b2 vs r\u00b3' }], { title: 'Kepler\\'s Third Law Verification', xaxis: {title: 'Orbital Radius\u00b3 (R\u2295\u00b3)'}, yaxis: {title: 'Orbital Period\u00b2 (hours\u00b2)'} }); } // Add event listeners document.querySelectorAll('input[type=\"range\"]').forEach(input => { input.addEventListener('input', function() { document.getElementById(this.id + 'Value').textContent = this.value; updateSimulation(); }); }); // Initial render updateSimulation(); })();","title":"Interactive Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#practical-applications","text":"","title":"Practical Applications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#satellite-deployment","text":"$$ r_{geo} = \\left(\\frac{T^2GM}{4\\pi^2}\\right)^{1/3} $$ Used to calculate geostationary orbit at ~42,164 km from Earth center","title":"Satellite Deployment"},{"location":"1%20Physics/2%20Gravity/Problem_1/#exoplanet-characterization","text":"Radial velocity method uses period measurements to estimate: $$ M \\propto \\frac{r^3}{T^2} $$","title":"Exoplanet Characterization"},{"location":"1%20Physics/2%20Gravity/Problem_1/#historical-navigation","text":"Ancient mariners used Moon orbital period (sidereal month = 27.3 days) for tidal predictions","title":"Historical Navigation"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Definitions First Cosmic Velocity Circular orbital velocity near the planet\u2019s surface: \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) Second Cosmic Velocity Escape velocity from the planet's gravity: \\(v_2 = \\sqrt{2} \\cdot v_1\\) Third Cosmic Velocity Escape velocity from the solar system: \\(v_3 = \\sqrt{\\frac{2GM_\\odot}{r}}\\) Application Satellites : Require first cosmic velocity to stay in orbit. Moon and Mars Missions : Require second cosmic velocity. Interstellar Probes : Must reach the third cosmic velocity. Interactive Chart Select a planet to see its cosmic velocities: Choose a planet: \ud83c\udf0d Earth \ud83d\udd34 Mars \ud83d\udfe4 Jupiter const planets = { earth: { name: \"Earth\", mass: 5.972e24, // in kg radius: 6371e3 // in meters }, mars: { name: \"Mars\", mass: 6.39e23, radius: 3389.5e3 }, jupiter: { name: \"Jupiter\", mass: 1.898e27, radius: 69911e3 } }; const G = 6.67430e-11; // Gravitational constant function calculateVelocities(planet) { const r = planet.radius; const M = planet.mass; const v1 = Math.sqrt(G * M / r); // 1st Cosmic Velocity const v2 = Math.sqrt(2) * v1; // 2nd Cosmic Velocity const v3 = Math.sqrt(G * 1.989e30 / (1.5e11)) + v2; // Approx. from Earth orbit + planet escape return [v1 / 1000, v2 / 1000, v3 / 1000]; // convert to km/s } const ctx = document.getElementById(\"velocityChart\").getContext(\"2d\"); let velocityChart = null; function updateChart(planetKey) { const planet = planets[planetKey]; const [v1, v2, v3] = calculateVelocities(planet); const data = { labels: [ \"1st Cosmic Velocity\\n(Orbiting)\", \"2nd Cosmic Velocity\\n(Escape)\", \"3rd Cosmic Velocity\\n(Leaving Solar System)\" ], datasets: [{ label: `Velocities for ${planet.name} (km/s)`, data: [v1, v2, v3], backgroundColor: ['#007bff', '#28a745', '#ff5722'] }] }; const config = { type: 'bar', data: data, options: { responsive: true, plugins: { title: { display: true, text: `Cosmic Velocities for ${planet.name}` }, tooltip: { callbacks: { label: function(context) { return `${context.dataset.label}: ${context.parsed.y.toFixed(2)} km/s`; } } } }, scales: { y: { beginAtZero: true, title: { display: true, text: 'Velocity (km/s)' } } } } }; if (velocityChart) { velocityChart.destroy(); } velocityChart = new Chart(ctx, config); } document.getElementById(\"planetSelector\").addEventListener(\"change\", (e) => { updateChart(e.target.value); }); updateChart(\"earth\"); // default chart","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions","text":"First Cosmic Velocity Circular orbital velocity near the planet\u2019s surface: \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) Second Cosmic Velocity Escape velocity from the planet's gravity: \\(v_2 = \\sqrt{2} \\cdot v_1\\) Third Cosmic Velocity Escape velocity from the solar system: \\(v_3 = \\sqrt{\\frac{2GM_\\odot}{r}}\\)","title":"Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#application","text":"Satellites : Require first cosmic velocity to stay in orbit. Moon and Mars Missions : Require second cosmic velocity. Interstellar Probes : Must reach the third cosmic velocity.","title":"Application"},{"location":"1%20Physics/2%20Gravity/Problem_2/#interactive-chart","text":"Select a planet to see its cosmic velocities: Choose a planet: \ud83c\udf0d Earth \ud83d\udd34 Mars \ud83d\udfe4 Jupiter const planets = { earth: { name: \"Earth\", mass: 5.972e24, // in kg radius: 6371e3 // in meters }, mars: { name: \"Mars\", mass: 6.39e23, radius: 3389.5e3 }, jupiter: { name: \"Jupiter\", mass: 1.898e27, radius: 69911e3 } }; const G = 6.67430e-11; // Gravitational constant function calculateVelocities(planet) { const r = planet.radius; const M = planet.mass; const v1 = Math.sqrt(G * M / r); // 1st Cosmic Velocity const v2 = Math.sqrt(2) * v1; // 2nd Cosmic Velocity const v3 = Math.sqrt(G * 1.989e30 / (1.5e11)) + v2; // Approx. from Earth orbit + planet escape return [v1 / 1000, v2 / 1000, v3 / 1000]; // convert to km/s } const ctx = document.getElementById(\"velocityChart\").getContext(\"2d\"); let velocityChart = null; function updateChart(planetKey) { const planet = planets[planetKey]; const [v1, v2, v3] = calculateVelocities(planet); const data = { labels: [ \"1st Cosmic Velocity\\n(Orbiting)\", \"2nd Cosmic Velocity\\n(Escape)\", \"3rd Cosmic Velocity\\n(Leaving Solar System)\" ], datasets: [{ label: `Velocities for ${planet.name} (km/s)`, data: [v1, v2, v3], backgroundColor: ['#007bff', '#28a745', '#ff5722'] }] }; const config = { type: 'bar', data: data, options: { responsive: true, plugins: { title: { display: true, text: `Cosmic Velocities for ${planet.name}` }, tooltip: { callbacks: { label: function(context) { return `${context.dataset.label}: ${context.parsed.y.toFixed(2)} km/s`; } } } }, scales: { y: { beginAtZero: true, title: { display: true, text: 'Velocity (km/s)' } } } } }; if (velocityChart) { velocityChart.destroy(); } velocityChart = new Chart(ctx, config); } document.getElementById(\"planetSelector\").addEventListener(\"change\", (e) => { updateChart(e.target.value); }); updateChart(\"earth\"); // default chart","title":"Interactive Chart"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3: Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth. Task Analyze the possible trajectories (e.g., parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform a numerical analysis to compute the path of the payload based on given initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion , reentry , or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity, accounting for initial velocities and directions. Gravitational Principles To understand the behavior of a freely released payload near Earth, we must rely on Newton's Law of Gravitation and the principles of orbital mechanics : The gravitational force between Earth and the payload is inversely proportional to the square of the distance between their centers. The object\u2019s trajectory will depend on its initial velocity and the direction of release. Equations Used: Newton\u2019s Law of Gravitation: $$ F = \\frac{GMm}{r^2} $$ Where: - \\( G \\) is the gravitational constant. - \\( M \\) is the mass of Earth. - \\( m \\) is the mass of the payload. - \\( r \\) is the distance between the center of the Earth and the payload. The trajectory can be computed using basic kinematic equations, updated step-by-step via numerical methods. Trajectories Types: Parabolic Trajectory: Occurs when the payload is released with a velocity below the escape velocity but at an angle. Hyperbolic Trajectory: Occurs when the payload\u2019s velocity exceeds the escape velocity. Elliptical Trajectory: Occurs when the payload\u2019s velocity is sufficient to form a closed orbit around Earth. Real-World Applications Space Mission Planning: Understanding payload trajectories is essential for deploying satellites or performing rendezvous operations. Reentry Scenarios: Calculating the correct reentry trajectory ensures safe return of payloads, such as space capsules. Escape Scenarios: Understanding escape velocities is crucial for interplanetary missions and space exploration. Computational Tool The following code simulates the trajectory of a freely released payload near Earth, taking into account the initial velocity and launch angle. The simulation provides a visual representation of the trajectory, illustrating how the payload will behave under the influence of gravity. Interactive Simulation: Initial Velocity (km/s): Launch Angle (\u00b0): const G = 6.67430e-11; // Gravitational constant const M = 5.972e24; // Earth mass in kg const R = 6371e3; // Earth radius in meters const dt = 0.05; // time step in seconds function calculateTrajectory(initialVelocity, launchAngle, tMax = 5000) { let x = 0; let y = R + 100000; // 100 km altitude let vx = initialVelocity * Math.cos(launchAngle * Math.PI / 180); let vy = initialVelocity * Math.sin(launchAngle * Math.PI / 180); let trajectory = []; for (let t = 0; t < tMax; t += dt) { let r = Math.sqrt(x * x + y * y); // distance from Earth's center let ax = -G * M * x / (r * r * r); // gravitational acceleration in x let ay = -G * M * y / (r * r * r); // gravitational acceleration in y vx += ax * dt; vy += ay * dt; x += vx * dt; y += vy * dt; trajectory.push({ x: x / 1000, y: y / 1000 }); // Convert to km if (y <= R) break; // Stop if it hits the Earth's surface } return trajectory; } const ctx = document.getElementById(\"trajectoryChart\").getContext(\"2d\"); let trajectoryChart = null; function updateChart() { const initialVelocity = parseFloat(document.getElementById(\"velocityInput\").value); const launchAngle = parseFloat(document.getElementById(\"angleInput\").value); const trajectory = calculateTrajectory(initialVelocity, launchAngle); const data = { labels: trajectory.map((point, idx) => idx * dt), datasets: [{ label: `Trajectory (Initial Velocity: ${initialVelocity} km/s, Angle: ${launchAngle}\u00b0)`, data: trajectory.map(point => ({ x: point.x, y: point.y })), borderColor: '#007bff', fill: false, tension: 0.1 }] }; const config = { type: 'line', data: data, options: { responsive: true, plugins: { title: { display: true, text: 'Payload Trajectory Near Earth' } }, scales: { x: { title: { display: true, text: 'Distance (km)' } }, y: { title: { display: true, text: 'Altitude (km)' } } } } }; if (trajectoryChart) { trajectoryChart.destroy(); } trajectoryChart = new Chart(ctx, config); } document.getElementById(\"velocityInput\").addEventListener(\"input\", updateChart); document.getElementById(\"angleInput\").addEventListener(\"input\", updateChart); updateChart(); // Initial chart","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task","text":"Analyze the possible trajectories (e.g., parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform a numerical analysis to compute the path of the payload based on given initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion , reentry , or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity, accounting for initial velocities and directions.","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_3/#gravitational-principles","text":"To understand the behavior of a freely released payload near Earth, we must rely on Newton's Law of Gravitation and the principles of orbital mechanics : The gravitational force between Earth and the payload is inversely proportional to the square of the distance between their centers. The object\u2019s trajectory will depend on its initial velocity and the direction of release.","title":"Gravitational Principles"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-used","text":"Newton\u2019s Law of Gravitation: $$ F = \\frac{GMm}{r^2} $$ Where: - \\( G \\) is the gravitational constant. - \\( M \\) is the mass of Earth. - \\( m \\) is the mass of the payload. - \\( r \\) is the distance between the center of the Earth and the payload. The trajectory can be computed using basic kinematic equations, updated step-by-step via numerical methods.","title":"Equations Used:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-types","text":"Parabolic Trajectory: Occurs when the payload is released with a velocity below the escape velocity but at an angle. Hyperbolic Trajectory: Occurs when the payload\u2019s velocity exceeds the escape velocity. Elliptical Trajectory: Occurs when the payload\u2019s velocity is sufficient to form a closed orbit around Earth.","title":"Trajectories Types:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-applications","text":"Space Mission Planning: Understanding payload trajectories is essential for deploying satellites or performing rendezvous operations. Reentry Scenarios: Calculating the correct reentry trajectory ensures safe return of payloads, such as space capsules. Escape Scenarios: Understanding escape velocities is crucial for interplanetary missions and space exploration.","title":"Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#computational-tool","text":"The following code simulates the trajectory of a freely released payload near Earth, taking into account the initial velocity and launch angle. The simulation provides a visual representation of the trajectory, illustrating how the payload will behave under the influence of gravity.","title":"Computational Tool"},{"location":"1%20Physics/2%20Gravity/Problem_3/#interactive-simulation","text":"Initial Velocity (km/s): Launch Angle (\u00b0): const G = 6.67430e-11; // Gravitational constant const M = 5.972e24; // Earth mass in kg const R = 6371e3; // Earth radius in meters const dt = 0.05; // time step in seconds function calculateTrajectory(initialVelocity, launchAngle, tMax = 5000) { let x = 0; let y = R + 100000; // 100 km altitude let vx = initialVelocity * Math.cos(launchAngle * Math.PI / 180); let vy = initialVelocity * Math.sin(launchAngle * Math.PI / 180); let trajectory = []; for (let t = 0; t < tMax; t += dt) { let r = Math.sqrt(x * x + y * y); // distance from Earth's center let ax = -G * M * x / (r * r * r); // gravitational acceleration in x let ay = -G * M * y / (r * r * r); // gravitational acceleration in y vx += ax * dt; vy += ay * dt; x += vx * dt; y += vy * dt; trajectory.push({ x: x / 1000, y: y / 1000 }); // Convert to km if (y <= R) break; // Stop if it hits the Earth's surface } return trajectory; } const ctx = document.getElementById(\"trajectoryChart\").getContext(\"2d\"); let trajectoryChart = null; function updateChart() { const initialVelocity = parseFloat(document.getElementById(\"velocityInput\").value); const launchAngle = parseFloat(document.getElementById(\"angleInput\").value); const trajectory = calculateTrajectory(initialVelocity, launchAngle); const data = { labels: trajectory.map((point, idx) => idx * dt), datasets: [{ label: `Trajectory (Initial Velocity: ${initialVelocity} km/s, Angle: ${launchAngle}\u00b0)`, data: trajectory.map(point => ({ x: point.x, y: point.y })), borderColor: '#007bff', fill: false, tension: 0.1 }] }; const config = { type: 'line', data: data, options: { responsive: true, plugins: { title: { display: true, text: 'Payload Trajectory Near Earth' } }, scales: { x: { title: { display: true, text: 'Distance (km)' } }, y: { title: { display: true, text: 'Altitude (km)' } } } } }; if (trajectoryChart) { trajectoryChart.destroy(); } trajectoryChart = new Chart(ctx, config); } document.getElementById(\"velocityInput\").addEventListener(\"input\", updateChart); document.getElementById(\"angleInput\").addEventListener(\"input\", updateChart); updateChart(); // Initial chart","title":"Interactive Simulation:"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1: Interference Patterns on a Water Surface Motivation Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be easily observed when ripples from different points meet, forming distinctive interference patterns. These patterns can show us how waves combine in different ways, either reinforcing each other or canceling out. Studying these patterns helps us understand wave behavior in a simple, visual way. It also allows us to explore important concepts, like the relationship between wave phase and the effects of multiple sources. This task offers a hands-on approach to learning about wave interactions and their real-world applications, making it an interesting and engaging way to dive into wave physics. Task Select a Regular Polygon: Choose a regular polygon (e.g., equilateral triangle, square, regular pentagon). Position the Sources: Place point wave sources at the vertices of the selected polygon. Wave Equations: Write the equations describing the waves emitted from each source, considering their respective positions. Superposition of Waves: Apply the principle of superposition by summing the wave displacements at each point on the water surface. Analyze Interference Patterns: Examine the resulting displacement as a function of position and time. Identify regions of constructive interference (wave amplification) and destructive interference (wave cancellation). Visualization: Present your findings graphically, illustrating the interference patterns for the chosen regular polygon. Computational Tool Polygon Sides (e.g., 3 for Triangle, 4 for Square): Wave Amplitude: const A = 1; // Amplitude of the wave const k = 2 * Math.PI / 10; // Example wavelength const omega = 2 * Math.PI * 1; // Example frequency // Function to calculate wave displacement at a point (x, y) function calculateWave(x, y, sources, t) { let displacement = 0; sources.forEach(source => { let dx = x - source.x; let dy = y - source.y; let r = Math.sqrt(dx * dx + dy * dy); // Distance from source to point displacement += A * Math.sin(k * r - omega * t); // Superposition of waves }); return displacement; } function generateInterferencePattern(sides, amplitude, t) { const width = 300; const height = 300; const centerX = width / 2; const centerY = height / 2; const radius = 100; const angleStep = 2 * Math.PI / sides; let sources = []; for (let i = 0; i < sides; i++) { let angle = i * angleStep; let x = centerX + radius * Math.cos(angle); let y = centerY + radius * Math.sin(angle); sources.push({ x, y }); } let data = []; const gridSize = 30; // Reducing the grid size further for (let x = 0; x < width; x += Math.floor(width / gridSize)) { for (let y = 0; y < height; y += Math.floor(height / gridSize)) { let displacement = calculateWave(x, y, sources, t); data.push({ x: x, y: y, displacement: displacement }); } } return data; } const ctx = document.getElementById(\"interferenceChart\").getContext(\"2d\"); let interferenceChart = null; function updateChart() { const sides = parseInt(document.getElementById(\"polygonSidesInput\").value); const amplitude = parseFloat(document.getElementById(\"waveAmplitudeInput\").value); const t = Date.now() / 1000; // Use current time as the time variable const patternData = generateInterferencePattern(sides, amplitude, t); // Simplified heatmap data const data = { labels: patternData.map(point => point.x), datasets: [{ label: `Interference Pattern (Polygon with ${sides} sides)`, data: patternData.map(point => ({ x: point.x, y: point.y, r: point.displacement })), backgroundColor: patternData.map(point => `rgba(0, 0, 255, ${Math.abs(point.displacement) / 5})`), // Lower alpha for smoother transition borderWidth: 0 }] }; const config = { type: 'scatter', data: data, options: { responsive: true, plugins: { title: { display: true, text: 'Water Surface Interference Pattern' } }, scales: { x: { display: false }, y: { display: false } } } }; if (interferenceChart) { interferenceChart.destroy(); } interferenceChart = new Chart(ctx, config); } document.getElementById(\"polygonSidesInput\").addEventListener(\"input\", updateChart); document.getElementById(\"waveAmplitudeInput\").addEventListener(\"input\", updateChart); updateChart(); // Initial chart","title":"Problem 1: Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1-interference-patterns-on-a-water-surface","text":"","title":"Problem 1: Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be easily observed when ripples from different points meet, forming distinctive interference patterns. These patterns can show us how waves combine in different ways, either reinforcing each other or canceling out. Studying these patterns helps us understand wave behavior in a simple, visual way. It also allows us to explore important concepts, like the relationship between wave phase and the effects of multiple sources. This task offers a hands-on approach to learning about wave interactions and their real-world applications, making it an interesting and engaging way to dive into wave physics.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#task","text":"Select a Regular Polygon: Choose a regular polygon (e.g., equilateral triangle, square, regular pentagon). Position the Sources: Place point wave sources at the vertices of the selected polygon. Wave Equations: Write the equations describing the waves emitted from each source, considering their respective positions. Superposition of Waves: Apply the principle of superposition by summing the wave displacements at each point on the water surface. Analyze Interference Patterns: Examine the resulting displacement as a function of position and time. Identify regions of constructive interference (wave amplification) and destructive interference (wave cancellation). Visualization: Present your findings graphically, illustrating the interference patterns for the chosen regular polygon.","title":"Task"},{"location":"1%20Physics/3%20Waves/Problem_1/#computational-tool","text":"Polygon Sides (e.g., 3 for Triangle, 4 for Square): Wave Amplitude: const A = 1; // Amplitude of the wave const k = 2 * Math.PI / 10; // Example wavelength const omega = 2 * Math.PI * 1; // Example frequency // Function to calculate wave displacement at a point (x, y) function calculateWave(x, y, sources, t) { let displacement = 0; sources.forEach(source => { let dx = x - source.x; let dy = y - source.y; let r = Math.sqrt(dx * dx + dy * dy); // Distance from source to point displacement += A * Math.sin(k * r - omega * t); // Superposition of waves }); return displacement; } function generateInterferencePattern(sides, amplitude, t) { const width = 300; const height = 300; const centerX = width / 2; const centerY = height / 2; const radius = 100; const angleStep = 2 * Math.PI / sides; let sources = []; for (let i = 0; i < sides; i++) { let angle = i * angleStep; let x = centerX + radius * Math.cos(angle); let y = centerY + radius * Math.sin(angle); sources.push({ x, y }); } let data = []; const gridSize = 30; // Reducing the grid size further for (let x = 0; x < width; x += Math.floor(width / gridSize)) { for (let y = 0; y < height; y += Math.floor(height / gridSize)) { let displacement = calculateWave(x, y, sources, t); data.push({ x: x, y: y, displacement: displacement }); } } return data; } const ctx = document.getElementById(\"interferenceChart\").getContext(\"2d\"); let interferenceChart = null; function updateChart() { const sides = parseInt(document.getElementById(\"polygonSidesInput\").value); const amplitude = parseFloat(document.getElementById(\"waveAmplitudeInput\").value); const t = Date.now() / 1000; // Use current time as the time variable const patternData = generateInterferencePattern(sides, amplitude, t); // Simplified heatmap data const data = { labels: patternData.map(point => point.x), datasets: [{ label: `Interference Pattern (Polygon with ${sides} sides)`, data: patternData.map(point => ({ x: point.x, y: point.y, r: point.displacement })), backgroundColor: patternData.map(point => `rgba(0, 0, 255, ${Math.abs(point.displacement) / 5})`), // Lower alpha for smoother transition borderWidth: 0 }] }; const config = { type: 'scatter', data: data, options: { responsive: true, plugins: { title: { display: true, text: 'Water Surface Interference Pattern' } }, scales: { x: { display: false }, y: { display: false } } } }; if (interferenceChart) { interferenceChart.destroy(); } interferenceChart = new Chart(ctx, config); } document.getElementById(\"polygonSidesInput\").addEventListener(\"input\", updateChart); document.getElementById(\"waveAmplitudeInput\").addEventListener(\"input\", updateChart); updateChart(); // Initial chart","title":"Computational Tool"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Simulating the Effects of the Lorentz Force 1. Introduction and Applications The Lorentz force, expressed as F = q(E + v \u00d7 B) , governs the motion of charged particles in electric and magnetic fields. It is fundamental in fields such as plasma physics, particle accelerators, and astrophysics. Key systems involving Lorentz force: - Particle accelerators (e.g., cyclotrons) - Mass spectrometers - Magnetic confinement in plasma physics Electric fields (E) accelerate charged particles, while magnetic fields (B) change their direction of motion, leading to complex trajectories. 2. Simulation of Particle Motion We implement a numerical simulation of a charged particle's trajectory under various field conditions: Uniform magnetic field Combined uniform electric and magnetic fields Crossed electric and magnetic fields Parameters such as charge (q), mass (m), initial velocity (v), and field strengths (E, B) can be adjusted. 3. Numerical Method We use the Euler method for integrating the equations of motion: \\[ \\mathbf{F} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) = m \\frac{d\\mathbf{v}}{dt} \\] At each time step: [ \\mathbf{a} = \\frac{\\mathbf{F}}{m} ] [ \\mathbf{v} {t+1} = \\mathbf{v}_t + \\mathbf{a} \\Delta t ] [ \\mathbf{r} } = \\mathbf{r t + \\mathbf{v} \\Delta t ] 4. Interactive Simulation Below is an interactive JavaScript simulation embedded directly in the page. You can modify parameters and visualize the particle's trajectory in 2D. Charge (q): Mass (m): Electric Field Ex: Electric Field Ey: Magnetic Field Bz: Initial Velocity Vx: Initial Velocity Vy: Run Simulation function runSimulation() { const q = parseFloat(document.getElementById(\"q\").value); const m = parseFloat(document.getElementById(\"m\").value); const Ex = parseFloat(document.getElementById(\"Ex\").value); const Ey = parseFloat(document.getElementById(\"Ey\").value); const Bz = parseFloat(document.getElementById(\"Bz\").value); let Vx = parseFloat(document.getElementById(\"Vx\").value); let Vy = parseFloat(document.getElementById(\"Vy\").value); const canvas = document.getElementById(\"lorentzCanvas\"); const ctx = canvas.getContext(\"2d\"); ctx.clearRect(0, 0, canvas.width, canvas.height); // Initial position in middle let x = canvas.width / 2; let y = canvas.height / 2; const dt = 0.1; ctx.beginPath(); ctx.moveTo(x, y); for(let i=0; i<1000; i++) { // Lorentz Force components const Fx = q * (Ex + Vy * Bz); const Fy = q * (Ey - Vx * Bz); // Acceleration const ax = Fx / m; const ay = Fy / m; // Update velocity Vx += ax * dt; Vy += ay * dt; // Update position x += Vx; y += Vy; ctx.lineTo(x, y); } ctx.strokeStyle = \"blue\"; ctx.lineWidth = 2; ctx.stroke(); } 5. Discussion The results demonstrate classical behaviors such as: Circular motion in uniform magnetic fields (Larmor orbits) Helical paths with combined E and B fields Drift motion with crossed fields These phenomena underpin technologies like cyclotrons and magnetic traps used in plasma confinement. 6. Extensions Possible extensions include: 3D trajectory visualization More accurate numerical methods (Runge-Kutta) Non-uniform or time-dependent fields Multiple particle simulations","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-introduction-and-applications","text":"The Lorentz force, expressed as F = q(E + v \u00d7 B) , governs the motion of charged particles in electric and magnetic fields. It is fundamental in fields such as plasma physics, particle accelerators, and astrophysics. Key systems involving Lorentz force: - Particle accelerators (e.g., cyclotrons) - Mass spectrometers - Magnetic confinement in plasma physics Electric fields (E) accelerate charged particles, while magnetic fields (B) change their direction of motion, leading to complex trajectories.","title":"1. Introduction and Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulation-of-particle-motion","text":"We implement a numerical simulation of a charged particle's trajectory under various field conditions: Uniform magnetic field Combined uniform electric and magnetic fields Crossed electric and magnetic fields Parameters such as charge (q), mass (m), initial velocity (v), and field strengths (E, B) can be adjusted.","title":"2. Simulation of Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-numerical-method","text":"We use the Euler method for integrating the equations of motion: \\[ \\mathbf{F} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) = m \\frac{d\\mathbf{v}}{dt} \\] At each time step: [ \\mathbf{a} = \\frac{\\mathbf{F}}{m} ] [ \\mathbf{v} {t+1} = \\mathbf{v}_t + \\mathbf{a} \\Delta t ] [ \\mathbf{r} } = \\mathbf{r t + \\mathbf{v} \\Delta t ]","title":"3. Numerical Method"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-interactive-simulation","text":"Below is an interactive JavaScript simulation embedded directly in the page. You can modify parameters and visualize the particle's trajectory in 2D. Charge (q): Mass (m): Electric Field Ex: Electric Field Ey: Magnetic Field Bz: Initial Velocity Vx: Initial Velocity Vy: Run Simulation function runSimulation() { const q = parseFloat(document.getElementById(\"q\").value); const m = parseFloat(document.getElementById(\"m\").value); const Ex = parseFloat(document.getElementById(\"Ex\").value); const Ey = parseFloat(document.getElementById(\"Ey\").value); const Bz = parseFloat(document.getElementById(\"Bz\").value); let Vx = parseFloat(document.getElementById(\"Vx\").value); let Vy = parseFloat(document.getElementById(\"Vy\").value); const canvas = document.getElementById(\"lorentzCanvas\"); const ctx = canvas.getContext(\"2d\"); ctx.clearRect(0, 0, canvas.width, canvas.height); // Initial position in middle let x = canvas.width / 2; let y = canvas.height / 2; const dt = 0.1; ctx.beginPath(); ctx.moveTo(x, y); for(let i=0; i<1000; i++) { // Lorentz Force components const Fx = q * (Ex + Vy * Bz); const Fy = q * (Ey - Vx * Bz); // Acceleration const ax = Fx / m; const ay = Fy / m; // Update velocity Vx += ax * dt; Vy += ay * dt; // Update position x += Vx; y += Vy; ctx.lineTo(x, y); } ctx.strokeStyle = \"blue\"; ctx.lineWidth = 2; ctx.stroke(); }","title":"4. Interactive Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-discussion","text":"The results demonstrate classical behaviors such as: Circular motion in uniform magnetic fields (Larmor orbits) Helical paths with combined E and B fields Drift motion with crossed fields These phenomena underpin technologies like cyclotrons and magnetic traps used in plasma confinement.","title":"5. Discussion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#6-extensions","text":"Possible extensions include: 3D trajectory visualization More accurate numerical methods (Runge-Kutta) Non-uniform or time-dependent fields Multiple particle simulations","title":"6. Extensions"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Circuits Problem 1 Equivalent Resistance Using Graph Theory Motivation Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for understanding and designing efficient systems. While traditional methods involve iteratively applying series and parallel resistor rules, these approaches become cumbersome for complex circuits. Graph theory offers a structured and algorithmic way to analyze circuits by representing them as graphs, where nodes correspond to junctions and edges represent resistors. This approach simplifies calculations and supports automation, making it highly valuable in circuit simulation and design. Fundamental Concepts and Formulas Series Resistors Resistors connected end-to-end, carrying the same current. Equivalent resistance: \\[ R_{eq} = R_1 + R_2 + \\cdots + R_n \\] Parallel Resistors Resistors connected across the same two nodes, sharing voltage. Equivalent resistance: \\[ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\cdots + \\frac{1}{R_n} \\] or equivalently: \\[ R_{eq} = \\left( \\sum_{i=1}^n \\frac{1}{R_i} \\right)^{-1} \\] Graph Theory Approach Representing circuits as graphs with nodes and weighted edges (resistors) allows systematic reduction: Series reduction: Combine resistors in series by summing resistances. Parallel reduction: Combine parallel resistors via reciprocal sum. Iterate until a single equivalent resistance remains between the input and output nodes. Interactive Circuit Simulator Add resistors in series or parallel, edit their values, and see the circuit visually and the equivalent resistance calculated in real-time. - input[type=\"number\"] { width: 80px; margin-right: 10px;} button { margin: 5px 8px 5px 0; padding: 6px 12px; cursor: pointer; } #resistor-list { margin-top: 15px; white-space: pre-wrap; font-family: monospace; } #canvas-container { text-align: center; margin-top: 20px; } #circuitCanvas { border: 1px solid #ccc; background: #f9f9f9; } .resistor-label { font-weight: bold; font-size: 12px; } Resistance (\u03a9): Add Resistor in Series Add Resistor in Parallel Reset Circuit Equivalent Resistance: 0 \u03a9 // Global variables let circuit = { type: 'series', // 'series' or 'parallel' resistors: [] }; // Resistor block size for drawing const resistorWidth = 60; const resistorHeight = 30; const spacing = 20; // Add resistor in series function addSeries() { const val = getResistanceInput(); if (val === null) return; if (circuit.resistors.length === 0) { circuit.type = 'series'; } else if (circuit.type !== 'series') { alert('Cannot mix series and parallel at this level. Reset and try again.'); return; } circuit.resistors.push({ resistance: val }); updateCircuit(); } // Add resistor in parallel function addParallel() { const val = getResistanceInput(); if (val === null) return; if (circuit.resistors.length === 0) { circuit.type = 'parallel'; } else if (circuit.type !== 'parallel') { alert('Cannot mix parallel and series at this level. Reset and try again.'); return; } circuit.resistors.push({ resistance: val }); updateCircuit(); } // Reset circuit function resetCircuit() { circuit = { type: 'series', resistors: [] }; updateCircuit(); } // Get and validate input resistance function getResistanceInput() { const input = document.getElementById('resistanceInput'); const val = parseFloat(input.value); if (isNaN(val) || val <= 0) { alert('Please enter a positive resistance value.'); return null; } return val; } // Calculate equivalent resistance recursively function calculateEquivalentResistance(circuit) { if (!circuit.resistors || circuit.resistors.length === 0) return 0; if (circuit.type === 'series') { return circuit.resistors.reduce((sum, r) => sum + r.resistance, 0); } else if (circuit.type === 'parallel') { const invSum = circuit.resistors.reduce((sum, r) => sum + 1/r.resistance, 0); return 1 / invSum; } return 0; } // Draw the circuit on canvas function drawCircuit() { const canvas = document.getElementById('circuitCanvas'); const ctx = canvas.getContext('2d'); ctx.clearRect(0, 0, canvas.width, canvas.height); if (circuit.resistors.length === 0) { ctx.font = '16px Arial'; ctx.fillText('No resistors added yet.', 20, canvas.height / 2); return; } ctx.strokeStyle = '#333'; ctx.lineWidth = 2; ctx.font = '14px Arial'; if (circuit.type === 'series') { // Draw series resistors horizontally let x = 20, y = canvas.height / 2; // Draw start line ctx.beginPath(); ctx.moveTo(x - 10, y); ctx.lineTo(x, y); ctx.stroke(); circuit.resistors.forEach((r, i) => { // Draw resistor rectangle ctx.strokeRect(x, y - resistorHeight/2, resistorWidth, resistorHeight); // Draw resistor label ctx.fillText(`R${i+1}: ${r.resistance.toFixed(2)} \u03a9`, x + 5, y + 5); // Draw wires ctx.beginPath(); ctx.moveTo(x + resistorWidth, y); x += resistorWidth + spacing; ctx.lineTo(x, y); ctx.stroke(); }); // Draw end line ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + 10, y); ctx.stroke(); } else if (circuit.type === 'parallel') { // Draw parallel resistors vertically stacked let x = canvas.width / 2; let startY = 20; const totalHeight = circuit.resistors.length * (resistorHeight + spacing) - spacing; // Draw vertical main lines ctx.beginPath(); ctx.moveTo(x - 50, startY); ctx.lineTo(x - 50, startY + totalHeight); ctx.moveTo(x + 50, startY); ctx.lineTo(x + 50, startY + totalHeight); ctx.stroke(); circuit.resistors.forEach((r, i) => { let y = startY + i * (resistorHeight + spacing); // Draw horizontal connecting wires to resistor ctx.beginPath(); ctx.moveTo(x - 50, y + resistorHeight/2); ctx.lineTo(x - 10, y + resistorHeight/2); ctx.moveTo(x + 10, y + resistorHeight/2); ctx.lineTo(x + 50, y + resistorHeight/2); ctx.stroke(); // Draw resistor rectangle ctx.strokeRect(x - 10, y, resistorWidth, resistorHeight); // Draw resistor label ctx.fillText(`R${i+1}: ${r.resistance.toFixed(2)} \u03a9`, x - 5, y + resistorHeight/1.7); }); } } // Update circuit UI and results function updateCircuit() { drawCircuit(); const Req = calculateEquivalentResistance(circuit); document.getElementById('result').innerText = `Equivalent Resistance: ${Req.toFixed(3)} \u03a9`; let listText = `Circuit type: ${circuit.type.toUpperCase()}\\nResistors:\\n`; circuit.resistors.forEach((r, i) => { listText += ` R${i+1}: ${r.resistance.toFixed(3)} \u03a9\\n`; }); document.getElementById('resistor-list').innerText = listText; } // Initialize resetCircuit();","title":"Circuits"},{"location":"1%20Physics/5%20Circuits/Problem_1/#circuits","text":"","title":"Circuits"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Calculating equivalent resistance is a fundamental problem in electrical circuits, essential for understanding and designing efficient systems. While traditional methods involve iteratively applying series and parallel resistor rules, these approaches become cumbersome for complex circuits. Graph theory offers a structured and algorithmic way to analyze circuits by representing them as graphs, where nodes correspond to junctions and edges represent resistors. This approach simplifies calculations and supports automation, making it highly valuable in circuit simulation and design.","title":"Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#fundamental-concepts-and-formulas","text":"","title":"Fundamental Concepts and Formulas"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-resistors","text":"Resistors connected end-to-end, carrying the same current. Equivalent resistance: \\[ R_{eq} = R_1 + R_2 + \\cdots + R_n \\]","title":"Series Resistors"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-resistors","text":"Resistors connected across the same two nodes, sharing voltage. Equivalent resistance: \\[ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\cdots + \\frac{1}{R_n} \\] or equivalently: \\[ R_{eq} = \\left( \\sum_{i=1}^n \\frac{1}{R_i} \\right)^{-1} \\]","title":"Parallel Resistors"},{"location":"1%20Physics/5%20Circuits/Problem_1/#graph-theory-approach","text":"Representing circuits as graphs with nodes and weighted edges (resistors) allows systematic reduction: Series reduction: Combine resistors in series by summing resistances. Parallel reduction: Combine parallel resistors via reciprocal sum. Iterate until a single equivalent resistance remains between the input and output nodes.","title":"Graph Theory Approach"},{"location":"1%20Physics/5%20Circuits/Problem_1/#interactive-circuit-simulator","text":"Add resistors in series or parallel, edit their values, and see the circuit visually and the equivalent resistance calculated in real-time. - input[type=\"number\"] { width: 80px; margin-right: 10px;} button { margin: 5px 8px 5px 0; padding: 6px 12px; cursor: pointer; } #resistor-list { margin-top: 15px; white-space: pre-wrap; font-family: monospace; } #canvas-container { text-align: center; margin-top: 20px; } #circuitCanvas { border: 1px solid #ccc; background: #f9f9f9; } .resistor-label { font-weight: bold; font-size: 12px; } Resistance (\u03a9): Add Resistor in Series Add Resistor in Parallel Reset Circuit Equivalent Resistance: 0 \u03a9 // Global variables let circuit = { type: 'series', // 'series' or 'parallel' resistors: [] }; // Resistor block size for drawing const resistorWidth = 60; const resistorHeight = 30; const spacing = 20; // Add resistor in series function addSeries() { const val = getResistanceInput(); if (val === null) return; if (circuit.resistors.length === 0) { circuit.type = 'series'; } else if (circuit.type !== 'series') { alert('Cannot mix series and parallel at this level. Reset and try again.'); return; } circuit.resistors.push({ resistance: val }); updateCircuit(); } // Add resistor in parallel function addParallel() { const val = getResistanceInput(); if (val === null) return; if (circuit.resistors.length === 0) { circuit.type = 'parallel'; } else if (circuit.type !== 'parallel') { alert('Cannot mix parallel and series at this level. Reset and try again.'); return; } circuit.resistors.push({ resistance: val }); updateCircuit(); } // Reset circuit function resetCircuit() { circuit = { type: 'series', resistors: [] }; updateCircuit(); } // Get and validate input resistance function getResistanceInput() { const input = document.getElementById('resistanceInput'); const val = parseFloat(input.value); if (isNaN(val) || val <= 0) { alert('Please enter a positive resistance value.'); return null; } return val; } // Calculate equivalent resistance recursively function calculateEquivalentResistance(circuit) { if (!circuit.resistors || circuit.resistors.length === 0) return 0; if (circuit.type === 'series') { return circuit.resistors.reduce((sum, r) => sum + r.resistance, 0); } else if (circuit.type === 'parallel') { const invSum = circuit.resistors.reduce((sum, r) => sum + 1/r.resistance, 0); return 1 / invSum; } return 0; } // Draw the circuit on canvas function drawCircuit() { const canvas = document.getElementById('circuitCanvas'); const ctx = canvas.getContext('2d'); ctx.clearRect(0, 0, canvas.width, canvas.height); if (circuit.resistors.length === 0) { ctx.font = '16px Arial'; ctx.fillText('No resistors added yet.', 20, canvas.height / 2); return; } ctx.strokeStyle = '#333'; ctx.lineWidth = 2; ctx.font = '14px Arial'; if (circuit.type === 'series') { // Draw series resistors horizontally let x = 20, y = canvas.height / 2; // Draw start line ctx.beginPath(); ctx.moveTo(x - 10, y); ctx.lineTo(x, y); ctx.stroke(); circuit.resistors.forEach((r, i) => { // Draw resistor rectangle ctx.strokeRect(x, y - resistorHeight/2, resistorWidth, resistorHeight); // Draw resistor label ctx.fillText(`R${i+1}: ${r.resistance.toFixed(2)} \u03a9`, x + 5, y + 5); // Draw wires ctx.beginPath(); ctx.moveTo(x + resistorWidth, y); x += resistorWidth + spacing; ctx.lineTo(x, y); ctx.stroke(); }); // Draw end line ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + 10, y); ctx.stroke(); } else if (circuit.type === 'parallel') { // Draw parallel resistors vertically stacked let x = canvas.width / 2; let startY = 20; const totalHeight = circuit.resistors.length * (resistorHeight + spacing) - spacing; // Draw vertical main lines ctx.beginPath(); ctx.moveTo(x - 50, startY); ctx.lineTo(x - 50, startY + totalHeight); ctx.moveTo(x + 50, startY); ctx.lineTo(x + 50, startY + totalHeight); ctx.stroke(); circuit.resistors.forEach((r, i) => { let y = startY + i * (resistorHeight + spacing); // Draw horizontal connecting wires to resistor ctx.beginPath(); ctx.moveTo(x - 50, y + resistorHeight/2); ctx.lineTo(x - 10, y + resistorHeight/2); ctx.moveTo(x + 10, y + resistorHeight/2); ctx.lineTo(x + 50, y + resistorHeight/2); ctx.stroke(); // Draw resistor rectangle ctx.strokeRect(x - 10, y, resistorWidth, resistorHeight); // Draw resistor label ctx.fillText(`R${i+1}: ${r.resistance.toFixed(2)} \u03a9`, x - 5, y + resistorHeight/1.7); }); } } // Update circuit UI and results function updateCircuit() { drawCircuit(); const Req = calculateEquivalentResistance(circuit); document.getElementById('result').innerText = `Equivalent Resistance: ${Req.toFixed(3)} \u03a9`; let listText = `Circuit type: ${circuit.type.toUpperCase()}\\nResistors:\\n`; circuit.resistors.forEach((r, i) => { listText += ` R${i+1}: ${r.resistance.toFixed(3)} \u03a9\\n`; }); document.getElementById('resistor-list').innerText = listText; } // Initialize resetCircuit();","title":"Interactive Circuit Simulator"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}