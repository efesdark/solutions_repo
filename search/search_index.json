{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion, while seemingly simple, provides a rich framework for exploring fundamental principles of physics. The problem at hand is straightforward: analyze how the range of a projectile depends on its angle of projection. Despite its simplicity, the topic involves complex relationships governed by both linear and quadratic equations, making it an insightful subject of study. A key factor that makes this investigation compelling is the number of free parameters involved in projectile motion equations, such as initial velocity, gravitational acceleration, and launch height. These parameters contribute to a diverse set of solutions that model real-world scenarios, from the trajectory of a soccer ball to the flight path of a missile. Task 1. Theoretical Foundation To analyze the range as a function of the angle of projection, we start by deriving the governing equations from fundamental principles of kinematics and dynamics. The motion of a projectile in the absence of air resistance follows Newton\u2019s second law: Equations of Motion: Horizontal displacement: $$ x = v_0 \\cos(\\theta) t $$ Vertical displacement: $$ y = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2 $$ Solving these equations yields the total time of flight \\( T \\) : $$ T = \\frac{2v_0 \\sin(\\theta)}{g} $$ Substituting into the horizontal displacement equation, we obtain the range \\( R \\) : $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ This equation shows that the range depends on the square of the initial velocity and the sine of twice the projection angle. 2. Analysis of the Range The range \\( R \\) is maximized when \\( \\sin(2\\theta) \\) reaches its maximum value (1), which occurs at \\( 2\\theta = 90^\\circ \\) , or \\( \\theta = 45^\\circ \\) . Increasing the initial velocity \\( v_0 \\) increases the range quadratically. A higher gravitational acceleration \\( g \\) reduces the range. For non-zero launch height, the equation for \\( R \\) becomes more complex, requiring further analysis. 3. Practical Applications Sports: Understanding how the angle influences projectile range helps optimize techniques in soccer, basketball, and javelin throwing. Engineering: In artillery and missile technology, precise control over launch angles is essential for maximizing impact range. Space Exploration: The principles of projectile motion extend to orbital mechanics and spacecraft trajectory planning. 4. Implementation To further analyze the range as a function of the projection angle, a computational tool can be developed: - Algorithm: Implement numerical simulations in Python or MATLAB to visualize projectile motion under varying conditions. - Graphical Representation: Generate plots of range versus launch angle to observe the dependency. - Advanced Considerations: Extend the model to include air resistance, variable wind conditions, and non-flat terrain. Conclusion The study of projectile motion offers valuable insights into both theoretical physics and practical applications. By understanding the mathematical framework and leveraging computational tools, we can develop a deeper appreciation of how varying initial conditions affect a projectile\u2019s trajectory. Future work may involve refining the model with real-world complexities such as air resistance and varying gravitational fields. Interactive Simulation Click to interact with parameters Initial Velocity (m/s): 20 Gravity (m/s\u00b2): 9.81 Launch Height (m): 0 (function() { // Calculation and plotting logic function calculateRange(theta, v0, g, h) { const thetaRad = theta * Math.PI / 180; const sinTheta = Math.sin(thetaRad); const cosTheta = Math.cos(thetaRad); const discriminant = (v0*sinTheta)**2 + 2*g*h; if(discriminant < 0) return 0; const t = (v0*sinTheta + Math.sqrt(discriminant))/g; return v0*cosTheta * t; } function updatePlot() { const v0 = parseFloat(document.getElementById('v0').value); const g = parseFloat(document.getElementById('gravity').value); const h = parseFloat(document.getElementById('height').value); const angles = Array.from({length: 90}, (_, i) => i); const ranges = angles.map(angle => calculateRange(angle, v0, g, h)); Plotly.newPlot('plotly-chart', [{ x: angles, y: ranges, type: 'scatter', mode: 'lines+markers' }], { title: `Range vs. Launch Angle (v\u2080=${v0}m/s, g=${g}m/s\u00b2, h=${h}m)`, xaxis: {title: 'Launch Angle (degrees)'}, yaxis: {title: 'Range (m)'} }); } // Event listeners document.querySelectorAll('input[type=\"range\"]').forEach(input => { input.addEventListener('input', function() { document.getElementById(this.id + 'Value').textContent = this.value; updatePlot(); }); }); // Initial plot updatePlot(); })();","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"Investigating the Range as a Function of the Angle of Projection","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion, while seemingly simple, provides a rich framework for exploring fundamental principles of physics. The problem at hand is straightforward: analyze how the range of a projectile depends on its angle of projection. Despite its simplicity, the topic involves complex relationships governed by both linear and quadratic equations, making it an insightful subject of study. A key factor that makes this investigation compelling is the number of free parameters involved in projectile motion equations, such as initial velocity, gravitational acceleration, and launch height. These parameters contribute to a diverse set of solutions that model real-world scenarios, from the trajectory of a soccer ball to the flight path of a missile.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#task","text":"","title":"Task"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"To analyze the range as a function of the angle of projection, we start by deriving the governing equations from fundamental principles of kinematics and dynamics. The motion of a projectile in the absence of air resistance follows Newton\u2019s second law: Equations of Motion: Horizontal displacement: $$ x = v_0 \\cos(\\theta) t $$ Vertical displacement: $$ y = v_0 \\sin(\\theta) t - \\frac{1}{2}gt^2 $$ Solving these equations yields the total time of flight \\( T \\) : $$ T = \\frac{2v_0 \\sin(\\theta)}{g} $$ Substituting into the horizontal displacement equation, we obtain the range \\( R \\) : $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ This equation shows that the range depends on the square of the initial velocity and the sine of twice the projection angle.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The range \\( R \\) is maximized when \\( \\sin(2\\theta) \\) reaches its maximum value (1), which occurs at \\( 2\\theta = 90^\\circ \\) , or \\( \\theta = 45^\\circ \\) . Increasing the initial velocity \\( v_0 \\) increases the range quadratically. A higher gravitational acceleration \\( g \\) reduces the range. For non-zero launch height, the equation for \\( R \\) becomes more complex, requiring further analysis.","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports: Understanding how the angle influences projectile range helps optimize techniques in soccer, basketball, and javelin throwing. Engineering: In artillery and missile technology, precise control over launch angles is essential for maximizing impact range. Space Exploration: The principles of projectile motion extend to orbital mechanics and spacecraft trajectory planning.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"To further analyze the range as a function of the projection angle, a computational tool can be developed: - Algorithm: Implement numerical simulations in Python or MATLAB to visualize projectile motion under varying conditions. - Graphical Representation: Generate plots of range versus launch angle to observe the dependency. - Advanced Considerations: Extend the model to include air resistance, variable wind conditions, and non-flat terrain.","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"The study of projectile motion offers valuable insights into both theoretical physics and practical applications. By understanding the mathematical framework and leveraging computational tools, we can develop a deeper appreciation of how varying initial conditions affect a projectile\u2019s trajectory. Future work may involve refining the model with real-world complexities such as air resistance and varying gravitational fields.","title":"Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#interactive-simulation","text":"Click to interact with parameters Initial Velocity (m/s): 20 Gravity (m/s\u00b2): 9.81 Launch Height (m): 0 (function() { // Calculation and plotting logic function calculateRange(theta, v0, g, h) { const thetaRad = theta * Math.PI / 180; const sinTheta = Math.sin(thetaRad); const cosTheta = Math.cos(thetaRad); const discriminant = (v0*sinTheta)**2 + 2*g*h; if(discriminant < 0) return 0; const t = (v0*sinTheta + Math.sqrt(discriminant))/g; return v0*cosTheta * t; } function updatePlot() { const v0 = parseFloat(document.getElementById('v0').value); const g = parseFloat(document.getElementById('gravity').value); const h = parseFloat(document.getElementById('height').value); const angles = Array.from({length: 90}, (_, i) => i); const ranges = angles.map(angle => calculateRange(angle, v0, g, h)); Plotly.newPlot('plotly-chart', [{ x: angles, y: ranges, type: 'scatter', mode: 'lines+markers' }], { title: `Range vs. Launch Angle (v\u2080=${v0}m/s, g=${g}m/s\u00b2, h=${h}m)`, xaxis: {title: 'Launch Angle (degrees)'}, yaxis: {title: 'Range (m)'} }); } // Event listeners document.querySelectorAll('input[type=\"range\"]').forEach(input => { input.addEventListener('input', function() { document.getElementById(this.id + 'Value').textContent = this.value; updatePlot(); }); }); // Initial plot updatePlot(); })();","title":"Interactive Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum exemplifies complex dynamics emerging from the interplay of damping, restoring, and driving forces. This system exhibits phenomena ranging from resonance to chaos, making it fundamental for understanding oscillatory systems in engineering and physics. Theoretical Foundation Governing Equation The motion is described by: $$ \\frac{d^2\\theta}{dt^2} + \\frac{b}{m}\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = \\frac{F}{mL}\\cos(\\omega_d t) $$ Linearized form (small angles): $$ \\frac{d^2\\theta}{dt^2} + 2\\beta\\omega_0\\frac{d\\theta}{dt} + \\omega_0^2\\theta = \\frac{F}{mL}\\cos(\\omega_d t) $$ Resonance Condition Maximum energy transfer occurs when: $$ \\omega_d = \\sqrt{\\omega_0^2 - 2\\beta^2} $$ Dynamics Analysis Parameter Effect on System Damping (\u03b2) \u2191 Resonance peak broadens Driving Force (F) \u2191 Amplitude increases Frequency Ratio (\u03c9_d/\u03c9_0) Phase shifts occur Practical Applications Energy Harvesting: Tuning \u03c9_d to match \u03c9\u2080 for maximum power Structural Engineering: Avoiding resonance in bridges Biological Systems: Neural oscillations modeling Interactive Simulation Damping (\u03b2): Force (F): Frequency (\u03c9_d): (function() { const solvePendulum = (beta, F, omega_d, tmax=30) => { const dt = 0.05; const omega0 = 1.0; let theta = 0.1, omega = 0; const solution = []; for(let t=0; t<=tmax; t+=dt) { const acceleration = F*Math.cos(omega_d*t) - 2*beta*omega0*omega - omega0**2*Math.sin(theta); omega += acceleration * dt; theta += omega * dt; solution.push({ t: t.toFixed(2), theta: theta, omega: omega }); } return solution; }; function updatePlot() { const beta = parseFloat(document.getElementById('beta').value); const F = parseFloat(document.getElementById('force').value); const omega_d = parseFloat(document.getElementById('freq').value); const data = solvePendulum(beta, F, omega_d); const trace1 = { x: data.map(d => d.t), y: data.map(d => d.theta), name: 'Angular Displacement', type: 'scatter' }; const trace2 = { x: data.map(d => d.theta), y: data.map(d => d.omega), name: 'Phase Portrait', mode: 'lines', type: 'scatter' }; Plotly.newPlot('pendulumPlot', [trace1, trace2], { title: `Forced Damped Pendulum Dynamics<br>\u03b2=${beta}, F=${F}, \u03c9<sub>d</sub>=${omega_d}`, grid: {rows: 1, columns: 2}, xaxis1: {title: 'Time (s)'}, yaxis1: {title: '\u03b8 (rad)'}, xaxis2: {title: '\u03b8 (rad)'}, yaxis2: {title: 'd\u03b8/dt (rad/s)'} }); } document.querySelectorAll('input[type=\"range\"]').forEach(input => { input.addEventListener('input', updatePlot); }); updatePlot(); })();","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"Investigating the Dynamics of a Forced Damped Pendulum","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum exemplifies complex dynamics emerging from the interplay of damping, restoring, and driving forces. This system exhibits phenomena ranging from resonance to chaos, making it fundamental for understanding oscillatory systems in engineering and physics.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#theoretical-foundation","text":"","title":"Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#governing-equation","text":"The motion is described by: $$ \\frac{d^2\\theta}{dt^2} + \\frac{b}{m}\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = \\frac{F}{mL}\\cos(\\omega_d t) $$ Linearized form (small angles): $$ \\frac{d^2\\theta}{dt^2} + 2\\beta\\omega_0\\frac{d\\theta}{dt} + \\omega_0^2\\theta = \\frac{F}{mL}\\cos(\\omega_d t) $$","title":"Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-condition","text":"Maximum energy transfer occurs when: $$ \\omega_d = \\sqrt{\\omega_0^2 - 2\\beta^2} $$","title":"Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#dynamics-analysis","text":"Parameter Effect on System Damping (\u03b2) \u2191 Resonance peak broadens Driving Force (F) \u2191 Amplitude increases Frequency Ratio (\u03c9_d/\u03c9_0) Phase shifts occur","title":"Dynamics Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#practical-applications","text":"Energy Harvesting: Tuning \u03c9_d to match \u03c9\u2080 for maximum power Structural Engineering: Avoiding resonance in bridges Biological Systems: Neural oscillations modeling","title":"Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#interactive-simulation","text":"Damping (\u03b2): Force (F): Frequency (\u03c9_d): (function() { const solvePendulum = (beta, F, omega_d, tmax=30) => { const dt = 0.05; const omega0 = 1.0; let theta = 0.1, omega = 0; const solution = []; for(let t=0; t<=tmax; t+=dt) { const acceleration = F*Math.cos(omega_d*t) - 2*beta*omega0*omega - omega0**2*Math.sin(theta); omega += acceleration * dt; theta += omega * dt; solution.push({ t: t.toFixed(2), theta: theta, omega: omega }); } return solution; }; function updatePlot() { const beta = parseFloat(document.getElementById('beta').value); const F = parseFloat(document.getElementById('force').value); const omega_d = parseFloat(document.getElementById('freq').value); const data = solvePendulum(beta, F, omega_d); const trace1 = { x: data.map(d => d.t), y: data.map(d => d.theta), name: 'Angular Displacement', type: 'scatter' }; const trace2 = { x: data.map(d => d.theta), y: data.map(d => d.omega), name: 'Phase Portrait', mode: 'lines', type: 'scatter' }; Plotly.newPlot('pendulumPlot', [trace1, trace2], { title: `Forced Damped Pendulum Dynamics<br>\u03b2=${beta}, F=${F}, \u03c9<sub>d</sub>=${omega_d}`, grid: {rows: 1, columns: 2}, xaxis1: {title: 'Time (s)'}, yaxis1: {title: '\u03b8 (rad)'}, xaxis2: {title: '\u03b8 (rad)'}, yaxis2: {title: 'd\u03b8/dt (rad/s)'} }); } document.querySelectorAll('input[type=\"range\"]').forEach(input => { input.addEventListener('input', updatePlot); }); updatePlot(); })();","title":"Interactive Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Theoretical Foundation From Newton's Law of Gravitation and centripetal force equivalence: $$ \\frac{GMm}{r^2} = \\frac{mv^2}{r} $$ Substituting orbital velocity \\(v = \\frac{2\\pi r}{T}\\) , we derive: $$ T^2 = \\left(\\frac{4\\pi^2}{GM}\\right)r^3 $$ Astronomical Significance Application Implementation Exoplanet Detection Mass estimation via period analysis Satellite Engineering Geostationary orbit calculation Galactic Dynamics Dark matter distribution studies Interactive Simulation Orbital Radius (Earth Radii): 60 Central Mass (Earth Masses): 1 (function() { const G = 6.67430e-11; // Gravitational constant const earthMass = 5.972e24; // kg const earthRadius = 6.371e6; // meters function calculatePeriod(r, M) { return Math.sqrt((4 * Math.PI**2 * r**3) / (G * M)); } function updateSimulation() { const radius = parseFloat(document.getElementById('radius').value); const mass = parseFloat(document.getElementById('mass').value); // Convert to SI units const rSI = radius * earthRadius; const MSI = mass * earthMass; // Calculate orbital period const T = calculatePeriod(rSI, MSI); // Generate orbit path const theta = Array.from({length: 100}, (_, i) => i * 2 * Math.PI / 100); const x = radius * theta.map(t => Math.cos(t)); const y = radius * theta.map(t => Math.sin(t)); // Update orbit plot Plotly.newPlot('orbitPlot', [{ x: x, y: y, mode: 'lines', name: 'Orbit', line: {color: '#00ff88'} }, { x: [0], y: [0], mode: 'markers', marker: {size: 20, color: '#1e90ff'}, name: 'Central Body' }], { title: `Orbital Period: ${(T/3600).toFixed(2)} hours`, showlegend: false, aspectratio: {x: 1, y: 1} }); // Generate verification data const radii = Array.from({length: 50}, (_, i) => 2 + (i*2)); const periods = radii.map(r => calculatePeriod(r * earthRadius, MSI) / 3600 ); // Update law verification plot Plotly.newPlot('lawVerification', [{ x: radii.map(r => r**3), y: periods.map(t => t**2), mode: 'lines+markers', name: 'T\u00b2 vs r\u00b3' }], { title: 'Kepler\\'s Third Law Verification', xaxis: {title: 'Orbital Radius\u00b3 (R\u2295\u00b3)'}, yaxis: {title: 'Orbital Period\u00b2 (hours\u00b2)'} }); } // Add event listeners document.querySelectorAll('input[type=\"range\"]').forEach(input => { input.addEventListener('input', function() { document.getElementById(this.id + 'Value').textContent = this.value; updateSimulation(); }); }); // Initial render updateSimulation(); })(); Practical Applications Satellite Deployment $$ r_{geo} = \\left(\\frac{T^2GM}{4\\pi^2}\\right)^{1/3} $$ Used to calculate geostationary orbit at ~42,164 km from Earth center Exoplanet Characterization Radial velocity method uses period measurements to estimate: $$ M \\propto \\frac{r^3}{T^2} $$ Historical Navigation Ancient mariners used Moon orbital period (sidereal month = 27.3 days) for tidal predictions","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#theoretical-foundation","text":"From Newton's Law of Gravitation and centripetal force equivalence: $$ \\frac{GMm}{r^2} = \\frac{mv^2}{r} $$ Substituting orbital velocity \\(v = \\frac{2\\pi r}{T}\\) , we derive: $$ T^2 = \\left(\\frac{4\\pi^2}{GM}\\right)r^3 $$","title":"Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#astronomical-significance","text":"Application Implementation Exoplanet Detection Mass estimation via period analysis Satellite Engineering Geostationary orbit calculation Galactic Dynamics Dark matter distribution studies","title":"Astronomical Significance"},{"location":"1%20Physics/2%20Gravity/Problem_1/#interactive-simulation","text":"Orbital Radius (Earth Radii): 60 Central Mass (Earth Masses): 1 (function() { const G = 6.67430e-11; // Gravitational constant const earthMass = 5.972e24; // kg const earthRadius = 6.371e6; // meters function calculatePeriod(r, M) { return Math.sqrt((4 * Math.PI**2 * r**3) / (G * M)); } function updateSimulation() { const radius = parseFloat(document.getElementById('radius').value); const mass = parseFloat(document.getElementById('mass').value); // Convert to SI units const rSI = radius * earthRadius; const MSI = mass * earthMass; // Calculate orbital period const T = calculatePeriod(rSI, MSI); // Generate orbit path const theta = Array.from({length: 100}, (_, i) => i * 2 * Math.PI / 100); const x = radius * theta.map(t => Math.cos(t)); const y = radius * theta.map(t => Math.sin(t)); // Update orbit plot Plotly.newPlot('orbitPlot', [{ x: x, y: y, mode: 'lines', name: 'Orbit', line: {color: '#00ff88'} }, { x: [0], y: [0], mode: 'markers', marker: {size: 20, color: '#1e90ff'}, name: 'Central Body' }], { title: `Orbital Period: ${(T/3600).toFixed(2)} hours`, showlegend: false, aspectratio: {x: 1, y: 1} }); // Generate verification data const radii = Array.from({length: 50}, (_, i) => 2 + (i*2)); const periods = radii.map(r => calculatePeriod(r * earthRadius, MSI) / 3600 ); // Update law verification plot Plotly.newPlot('lawVerification', [{ x: radii.map(r => r**3), y: periods.map(t => t**2), mode: 'lines+markers', name: 'T\u00b2 vs r\u00b3' }], { title: 'Kepler\\'s Third Law Verification', xaxis: {title: 'Orbital Radius\u00b3 (R\u2295\u00b3)'}, yaxis: {title: 'Orbital Period\u00b2 (hours\u00b2)'} }); } // Add event listeners document.querySelectorAll('input[type=\"range\"]').forEach(input => { input.addEventListener('input', function() { document.getElementById(this.id + 'Value').textContent = this.value; updateSimulation(); }); }); // Initial render updateSimulation(); })();","title":"Interactive Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#practical-applications","text":"","title":"Practical Applications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#satellite-deployment","text":"$$ r_{geo} = \\left(\\frac{T^2GM}{4\\pi^2}\\right)^{1/3} $$ Used to calculate geostationary orbit at ~42,164 km from Earth center","title":"Satellite Deployment"},{"location":"1%20Physics/2%20Gravity/Problem_1/#exoplanet-characterization","text":"Radial velocity method uses period measurements to estimate: $$ M \\propto \\frac{r^3}{T^2} $$","title":"Exoplanet Characterization"},{"location":"1%20Physics/2%20Gravity/Problem_1/#historical-navigation","text":"Ancient mariners used Moon orbital period (sidereal month = 27.3 days) for tidal predictions","title":"Historical Navigation"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. Definitions First Cosmic Velocity Circular orbital velocity near the planet\u2019s surface: \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) Second Cosmic Velocity Escape velocity from the planet's gravity: \\(v_2 = \\sqrt{2} \\cdot v_1\\) Third Cosmic Velocity Escape velocity from the solar system: \\(v_3 = \\sqrt{\\frac{2GM_\\odot}{r}}\\) Application Satellites : Require first cosmic velocity to stay in orbit. Moon and Mars Missions : Require second cosmic velocity. Interstellar Probes : Must reach the third cosmic velocity. Interactive Chart Select a planet to see its cosmic velocities: Choose a planet: \ud83c\udf0d Earth \ud83d\udd34 Mars \ud83d\udfe4 Jupiter const planets = { earth: { name: \"Earth\", mass: 5.972e24, // in kg radius: 6371e3 // in meters }, mars: { name: \"Mars\", mass: 6.39e23, radius: 3389.5e3 }, jupiter: { name: \"Jupiter\", mass: 1.898e27, radius: 69911e3 } }; const G = 6.67430e-11; // Gravitational constant function calculateVelocities(planet) { const r = planet.radius; const M = planet.mass; const v1 = Math.sqrt(G * M / r); // 1st Cosmic Velocity const v2 = Math.sqrt(2) * v1; // 2nd Cosmic Velocity const v3 = Math.sqrt(G * 1.989e30 / (1.5e11)) + v2; // Approx. from Earth orbit + planet escape return [v1 / 1000, v2 / 1000, v3 / 1000]; // convert to km/s } const ctx = document.getElementById(\"velocityChart\").getContext(\"2d\"); let velocityChart = null; function updateChart(planetKey) { const planet = planets[planetKey]; const [v1, v2, v3] = calculateVelocities(planet); const data = { labels: [ \"1st Cosmic Velocity\\n(Orbiting)\", \"2nd Cosmic Velocity\\n(Escape)\", \"3rd Cosmic Velocity\\n(Leaving Solar System)\" ], datasets: [{ label: `Velocities for ${planet.name} (km/s)`, data: [v1, v2, v3], backgroundColor: ['#007bff', '#28a745', '#ff5722'] }] }; const config = { type: 'bar', data: data, options: { responsive: true, plugins: { title: { display: true, text: `Cosmic Velocities for ${planet.name}` }, tooltip: { callbacks: { label: function(context) { return `${context.dataset.label}: ${context.parsed.y.toFixed(2)} km/s`; } } } }, scales: { y: { beginAtZero: true, title: { display: true, text: 'Velocity (km/s)' } } } } }; if (velocityChart) { velocityChart.destroy(); } velocityChart = new Chart(ctx, config); } document.getElementById(\"planetSelector\").addEventListener(\"change\", (e) => { updateChart(e.target.value); }); updateChart(\"earth\"); // default chart","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions","text":"First Cosmic Velocity Circular orbital velocity near the planet\u2019s surface: \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) Second Cosmic Velocity Escape velocity from the planet's gravity: \\(v_2 = \\sqrt{2} \\cdot v_1\\) Third Cosmic Velocity Escape velocity from the solar system: \\(v_3 = \\sqrt{\\frac{2GM_\\odot}{r}}\\)","title":"Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#application","text":"Satellites : Require first cosmic velocity to stay in orbit. Moon and Mars Missions : Require second cosmic velocity. Interstellar Probes : Must reach the third cosmic velocity.","title":"Application"},{"location":"1%20Physics/2%20Gravity/Problem_2/#interactive-chart","text":"Select a planet to see its cosmic velocities: Choose a planet: \ud83c\udf0d Earth \ud83d\udd34 Mars \ud83d\udfe4 Jupiter const planets = { earth: { name: \"Earth\", mass: 5.972e24, // in kg radius: 6371e3 // in meters }, mars: { name: \"Mars\", mass: 6.39e23, radius: 3389.5e3 }, jupiter: { name: \"Jupiter\", mass: 1.898e27, radius: 69911e3 } }; const G = 6.67430e-11; // Gravitational constant function calculateVelocities(planet) { const r = planet.radius; const M = planet.mass; const v1 = Math.sqrt(G * M / r); // 1st Cosmic Velocity const v2 = Math.sqrt(2) * v1; // 2nd Cosmic Velocity const v3 = Math.sqrt(G * 1.989e30 / (1.5e11)) + v2; // Approx. from Earth orbit + planet escape return [v1 / 1000, v2 / 1000, v3 / 1000]; // convert to km/s } const ctx = document.getElementById(\"velocityChart\").getContext(\"2d\"); let velocityChart = null; function updateChart(planetKey) { const planet = planets[planetKey]; const [v1, v2, v3] = calculateVelocities(planet); const data = { labels: [ \"1st Cosmic Velocity\\n(Orbiting)\", \"2nd Cosmic Velocity\\n(Escape)\", \"3rd Cosmic Velocity\\n(Leaving Solar System)\" ], datasets: [{ label: `Velocities for ${planet.name} (km/s)`, data: [v1, v2, v3], backgroundColor: ['#007bff', '#28a745', '#ff5722'] }] }; const config = { type: 'bar', data: data, options: { responsive: true, plugins: { title: { display: true, text: `Cosmic Velocities for ${planet.name}` }, tooltip: { callbacks: { label: function(context) { return `${context.dataset.label}: ${context.parsed.y.toFixed(2)} km/s`; } } } }, scales: { y: { beginAtZero: true, title: { display: true, text: 'Velocity (km/s)' } } } } }; if (velocityChart) { velocityChart.destroy(); } velocityChart = new Chart(ctx, config); } document.getElementById(\"planetSelector\").addEventListener(\"change\", (e) => { updateChart(e.target.value); }); updateChart(\"earth\"); // default chart","title":"Interactive Chart"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3: Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth. Task Analyze the possible trajectories (e.g., parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform a numerical analysis to compute the path of the payload based on given initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion , reentry , or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity, accounting for initial velocities and directions. Gravitational Principles To understand the behavior of a freely released payload near Earth, we must rely on Newton's Law of Gravitation and the principles of orbital mechanics : The gravitational force between Earth and the payload is inversely proportional to the square of the distance between their centers. The object\u2019s trajectory will depend on its initial velocity and the direction of release. Equations Used: Newton\u2019s Law of Gravitation: $$ F = \\frac{GMm}{r^2} $$ Where: - \\( G \\) is the gravitational constant. - \\( M \\) is the mass of Earth. - \\( m \\) is the mass of the payload. - \\( r \\) is the distance between the center of the Earth and the payload. The trajectory can be computed using basic kinematic equations, updated step-by-step via numerical methods. Trajectories Types: Parabolic Trajectory: Occurs when the payload is released with a velocity below the escape velocity but at an angle. Hyperbolic Trajectory: Occurs when the payload\u2019s velocity exceeds the escape velocity. Elliptical Trajectory: Occurs when the payload\u2019s velocity is sufficient to form a closed orbit around Earth. Real-World Applications Space Mission Planning: Understanding payload trajectories is essential for deploying satellites or performing rendezvous operations. Reentry Scenarios: Calculating the correct reentry trajectory ensures safe return of payloads, such as space capsules. Escape Scenarios: Understanding escape velocities is crucial for interplanetary missions and space exploration. Computational Tool The following code simulates the trajectory of a freely released payload near Earth, taking into account the initial velocity and launch angle. The simulation provides a visual representation of the trajectory, illustrating how the payload will behave under the influence of gravity. Interactive Simulation: Initial Velocity (km/s): Launch Angle (\u00b0): const G = 6.67430e-11; // Gravitational constant const M = 5.972e24; // Earth mass in kg const R = 6371e3; // Earth radius in meters const dt = 0.05; // time step in seconds function calculateTrajectory(initialVelocity, launchAngle, tMax = 5000) { let x = 0; let y = R + 100000; // 100 km altitude let vx = initialVelocity * Math.cos(launchAngle * Math.PI / 180); let vy = initialVelocity * Math.sin(launchAngle * Math.PI / 180); let trajectory = []; for (let t = 0; t < tMax; t += dt) { let r = Math.sqrt(x * x + y * y); // distance from Earth's center let ax = -G * M * x / (r * r * r); // gravitational acceleration in x let ay = -G * M * y / (r * r * r); // gravitational acceleration in y vx += ax * dt; vy += ay * dt; x += vx * dt; y += vy * dt; trajectory.push({ x: x / 1000, y: y / 1000 }); // Convert to km if (y <= R) break; // Stop if it hits the Earth's surface } return trajectory; } const ctx = document.getElementById(\"trajectoryChart\").getContext(\"2d\"); let trajectoryChart = null; function updateChart() { const initialVelocity = parseFloat(document.getElementById(\"velocityInput\").value); const launchAngle = parseFloat(document.getElementById(\"angleInput\").value); const trajectory = calculateTrajectory(initialVelocity, launchAngle); const data = { labels: trajectory.map((point, idx) => idx * dt), datasets: [{ label: `Trajectory (Initial Velocity: ${initialVelocity} km/s, Angle: ${launchAngle}\u00b0)`, data: trajectory.map(point => ({ x: point.x, y: point.y })), borderColor: '#007bff', fill: false, tension: 0.1 }] }; const config = { type: 'line', data: data, options: { responsive: true, plugins: { title: { display: true, text: 'Payload Trajectory Near Earth' } }, scales: { x: { title: { display: true, text: 'Distance (km)' } }, y: { title: { display: true, text: 'Altitude (km)' } } } } }; if (trajectoryChart) { trajectoryChart.destroy(); } trajectoryChart = new Chart(ctx, config); } document.getElementById(\"velocityInput\").addEventListener(\"input\", updateChart); document.getElementById(\"angleInput\").addEventListener(\"input\", updateChart); updateChart(); // Initial chart","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions and gravitational forces. This scenario presents a rich problem, blending principles of orbital mechanics and numerical methods. Understanding the potential trajectories is vital for space missions, such as deploying payloads or returning objects to Earth.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#task","text":"Analyze the possible trajectories (e.g., parabolic, hyperbolic, elliptical) of a payload released near Earth. Perform a numerical analysis to compute the path of the payload based on given initial conditions (position, velocity, and altitude). Discuss how these trajectories relate to orbital insertion , reentry , or escape scenarios. Develop a computational tool to simulate and visualize the motion of the payload under Earth's gravity, accounting for initial velocities and directions.","title":"Task"},{"location":"1%20Physics/2%20Gravity/Problem_3/#gravitational-principles","text":"To understand the behavior of a freely released payload near Earth, we must rely on Newton's Law of Gravitation and the principles of orbital mechanics : The gravitational force between Earth and the payload is inversely proportional to the square of the distance between their centers. The object\u2019s trajectory will depend on its initial velocity and the direction of release.","title":"Gravitational Principles"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-used","text":"Newton\u2019s Law of Gravitation: $$ F = \\frac{GMm}{r^2} $$ Where: - \\( G \\) is the gravitational constant. - \\( M \\) is the mass of Earth. - \\( m \\) is the mass of the payload. - \\( r \\) is the distance between the center of the Earth and the payload. The trajectory can be computed using basic kinematic equations, updated step-by-step via numerical methods.","title":"Equations Used:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-types","text":"Parabolic Trajectory: Occurs when the payload is released with a velocity below the escape velocity but at an angle. Hyperbolic Trajectory: Occurs when the payload\u2019s velocity exceeds the escape velocity. Elliptical Trajectory: Occurs when the payload\u2019s velocity is sufficient to form a closed orbit around Earth.","title":"Trajectories Types:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-applications","text":"Space Mission Planning: Understanding payload trajectories is essential for deploying satellites or performing rendezvous operations. Reentry Scenarios: Calculating the correct reentry trajectory ensures safe return of payloads, such as space capsules. Escape Scenarios: Understanding escape velocities is crucial for interplanetary missions and space exploration.","title":"Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#computational-tool","text":"The following code simulates the trajectory of a freely released payload near Earth, taking into account the initial velocity and launch angle. The simulation provides a visual representation of the trajectory, illustrating how the payload will behave under the influence of gravity.","title":"Computational Tool"},{"location":"1%20Physics/2%20Gravity/Problem_3/#interactive-simulation","text":"Initial Velocity (km/s): Launch Angle (\u00b0): const G = 6.67430e-11; // Gravitational constant const M = 5.972e24; // Earth mass in kg const R = 6371e3; // Earth radius in meters const dt = 0.05; // time step in seconds function calculateTrajectory(initialVelocity, launchAngle, tMax = 5000) { let x = 0; let y = R + 100000; // 100 km altitude let vx = initialVelocity * Math.cos(launchAngle * Math.PI / 180); let vy = initialVelocity * Math.sin(launchAngle * Math.PI / 180); let trajectory = []; for (let t = 0; t < tMax; t += dt) { let r = Math.sqrt(x * x + y * y); // distance from Earth's center let ax = -G * M * x / (r * r * r); // gravitational acceleration in x let ay = -G * M * y / (r * r * r); // gravitational acceleration in y vx += ax * dt; vy += ay * dt; x += vx * dt; y += vy * dt; trajectory.push({ x: x / 1000, y: y / 1000 }); // Convert to km if (y <= R) break; // Stop if it hits the Earth's surface } return trajectory; } const ctx = document.getElementById(\"trajectoryChart\").getContext(\"2d\"); let trajectoryChart = null; function updateChart() { const initialVelocity = parseFloat(document.getElementById(\"velocityInput\").value); const launchAngle = parseFloat(document.getElementById(\"angleInput\").value); const trajectory = calculateTrajectory(initialVelocity, launchAngle); const data = { labels: trajectory.map((point, idx) => idx * dt), datasets: [{ label: `Trajectory (Initial Velocity: ${initialVelocity} km/s, Angle: ${launchAngle}\u00b0)`, data: trajectory.map(point => ({ x: point.x, y: point.y })), borderColor: '#007bff', fill: false, tension: 0.1 }] }; const config = { type: 'line', data: data, options: { responsive: true, plugins: { title: { display: true, text: 'Payload Trajectory Near Earth' } }, scales: { x: { title: { display: true, text: 'Distance (km)' } }, y: { title: { display: true, text: 'Altitude (km)' } } } } }; if (trajectoryChart) { trajectoryChart.destroy(); } trajectoryChart = new Chart(ctx, config); } document.getElementById(\"velocityInput\").addEventListener(\"input\", updateChart); document.getElementById(\"angleInput\").addEventListener(\"input\", updateChart); updateChart(); // Initial chart","title":"Interactive Simulation:"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1: Interference Patterns on a Water Surface Motivation Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be easily observed when ripples from different points meet, forming distinctive interference patterns. These patterns can show us how waves combine in different ways, either reinforcing each other or canceling out. Studying these patterns helps us understand wave behavior in a simple, visual way. It also allows us to explore important concepts, like the relationship between wave phase and the effects of multiple sources. This task offers a hands-on approach to learning about wave interactions and their real-world applications, making it an interesting and engaging way to dive into wave physics. Task Select a Regular Polygon: Choose a regular polygon (e.g., equilateral triangle, square, regular pentagon). Position the Sources: Place point wave sources at the vertices of the selected polygon. Wave Equations: Write the equations describing the waves emitted from each source, considering their respective positions. Superposition of Waves: Apply the principle of superposition by summing the wave displacements at each point on the water surface. Analyze Interference Patterns: Examine the resulting displacement as a function of position and time. Identify regions of constructive interference (wave amplification) and destructive interference (wave cancellation). Visualization: Present your findings graphically, illustrating the interference patterns for the chosen regular polygon. Computational Tool Polygon Sides (e.g., 3 for Triangle, 4 for Square): Wave Amplitude: const A = 1; // Amplitude of the wave const k = 2 * Math.PI / 10; // Example wavelength const omega = 2 * Math.PI * 1; // Example frequency // Function to calculate wave displacement at a point (x, y) function calculateWave(x, y, sources, t) { let displacement = 0; sources.forEach(source => { let dx = x - source.x; let dy = y - source.y; let r = Math.sqrt(dx * dx + dy * dy); // Distance from source to point displacement += A * Math.sin(k * r - omega * t); // Superposition of waves }); return displacement; } function generateInterferencePattern(sides, amplitude, t) { const width = 300; const height = 300; const centerX = width / 2; const centerY = height / 2; const radius = 100; const angleStep = 2 * Math.PI / sides; let sources = []; for (let i = 0; i < sides; i++) { let angle = i * angleStep; let x = centerX + radius * Math.cos(angle); let y = centerY + radius * Math.sin(angle); sources.push({ x, y }); } let data = []; const gridSize = 30; // Reducing the grid size further for (let x = 0; x < width; x += Math.floor(width / gridSize)) { for (let y = 0; y < height; y += Math.floor(height / gridSize)) { let displacement = calculateWave(x, y, sources, t); data.push({ x: x, y: y, displacement: displacement }); } } return data; } const ctx = document.getElementById(\"interferenceChart\").getContext(\"2d\"); let interferenceChart = null; function updateChart() { const sides = parseInt(document.getElementById(\"polygonSidesInput\").value); const amplitude = parseFloat(document.getElementById(\"waveAmplitudeInput\").value); const t = Date.now() / 1000; // Use current time as the time variable const patternData = generateInterferencePattern(sides, amplitude, t); // Simplified heatmap data const data = { labels: patternData.map(point => point.x), datasets: [{ label: `Interference Pattern (Polygon with ${sides} sides)`, data: patternData.map(point => ({ x: point.x, y: point.y, r: point.displacement })), backgroundColor: patternData.map(point => `rgba(0, 0, 255, ${Math.abs(point.displacement) / 5})`), // Lower alpha for smoother transition borderWidth: 0 }] }; const config = { type: 'scatter', data: data, options: { responsive: true, plugins: { title: { display: true, text: 'Water Surface Interference Pattern' } }, scales: { x: { display: false }, y: { display: false } } } }; if (interferenceChart) { interferenceChart.destroy(); } interferenceChart = new Chart(ctx, config); } document.getElementById(\"polygonSidesInput\").addEventListener(\"input\", updateChart); document.getElementById(\"waveAmplitudeInput\").addEventListener(\"input\", updateChart); updateChart(); // Initial chart","title":"Problem 1: Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1-interference-patterns-on-a-water-surface","text":"","title":"Problem 1: Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap, creating new patterns. On a water surface, this can be easily observed when ripples from different points meet, forming distinctive interference patterns. These patterns can show us how waves combine in different ways, either reinforcing each other or canceling out. Studying these patterns helps us understand wave behavior in a simple, visual way. It also allows us to explore important concepts, like the relationship between wave phase and the effects of multiple sources. This task offers a hands-on approach to learning about wave interactions and their real-world applications, making it an interesting and engaging way to dive into wave physics.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#task","text":"Select a Regular Polygon: Choose a regular polygon (e.g., equilateral triangle, square, regular pentagon). Position the Sources: Place point wave sources at the vertices of the selected polygon. Wave Equations: Write the equations describing the waves emitted from each source, considering their respective positions. Superposition of Waves: Apply the principle of superposition by summing the wave displacements at each point on the water surface. Analyze Interference Patterns: Examine the resulting displacement as a function of position and time. Identify regions of constructive interference (wave amplification) and destructive interference (wave cancellation). Visualization: Present your findings graphically, illustrating the interference patterns for the chosen regular polygon.","title":"Task"},{"location":"1%20Physics/3%20Waves/Problem_1/#computational-tool","text":"Polygon Sides (e.g., 3 for Triangle, 4 for Square): Wave Amplitude: const A = 1; // Amplitude of the wave const k = 2 * Math.PI / 10; // Example wavelength const omega = 2 * Math.PI * 1; // Example frequency // Function to calculate wave displacement at a point (x, y) function calculateWave(x, y, sources, t) { let displacement = 0; sources.forEach(source => { let dx = x - source.x; let dy = y - source.y; let r = Math.sqrt(dx * dx + dy * dy); // Distance from source to point displacement += A * Math.sin(k * r - omega * t); // Superposition of waves }); return displacement; } function generateInterferencePattern(sides, amplitude, t) { const width = 300; const height = 300; const centerX = width / 2; const centerY = height / 2; const radius = 100; const angleStep = 2 * Math.PI / sides; let sources = []; for (let i = 0; i < sides; i++) { let angle = i * angleStep; let x = centerX + radius * Math.cos(angle); let y = centerY + radius * Math.sin(angle); sources.push({ x, y }); } let data = []; const gridSize = 30; // Reducing the grid size further for (let x = 0; x < width; x += Math.floor(width / gridSize)) { for (let y = 0; y < height; y += Math.floor(height / gridSize)) { let displacement = calculateWave(x, y, sources, t); data.push({ x: x, y: y, displacement: displacement }); } } return data; } const ctx = document.getElementById(\"interferenceChart\").getContext(\"2d\"); let interferenceChart = null; function updateChart() { const sides = parseInt(document.getElementById(\"polygonSidesInput\").value); const amplitude = parseFloat(document.getElementById(\"waveAmplitudeInput\").value); const t = Date.now() / 1000; // Use current time as the time variable const patternData = generateInterferencePattern(sides, amplitude, t); // Simplified heatmap data const data = { labels: patternData.map(point => point.x), datasets: [{ label: `Interference Pattern (Polygon with ${sides} sides)`, data: patternData.map(point => ({ x: point.x, y: point.y, r: point.displacement })), backgroundColor: patternData.map(point => `rgba(0, 0, 255, ${Math.abs(point.displacement) / 5})`), // Lower alpha for smoother transition borderWidth: 0 }] }; const config = { type: 'scatter', data: data, options: { responsive: true, plugins: { title: { display: true, text: 'Water Surface Interference Pattern' } }, scales: { x: { display: false }, y: { display: false } } } }; if (interferenceChart) { interferenceChart.destroy(); } interferenceChart = new Chart(ctx, config); } document.getElementById(\"polygonSidesInput\").addEventListener(\"input\", updateChart); document.getElementById(\"waveAmplitudeInput\").addEventListener(\"input\", updateChart); updateChart(); // Initial chart","title":"Computational Tool"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Electromagnetism: Lorentz Force Simulation Problem 1: Simulating the Effects of the Lorentz Force Motivation The Lorentz force describes the combined effect of electric and magnetic fields on a moving charged particle. It is a cornerstone of electromagnetism and plays a crucial role in: Plasma physics Particle accelerators Mass spectrometry Astrophysical plasmas Fusion devices (e.g., Tokamaks) The Lorentz force is defined by the following vector equation: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: - \\( \\vec{F} \\) is the force experienced by the particle (in newtons) - \\( q \\) is the charge of the particle (in coulombs) - \\( \\vec{E} \\) is the electric field (in volts per meter) - \\( \\vec{v} \\) is the velocity of the particle (in meters per second) - \\( \\vec{B} \\) is the magnetic field (in teslas) Understanding the behavior of charged particles in various field configurations allows us to model and design devices used in modern physics and engineering. 1. Exploration of Applications Real-World Systems Where Lorentz Force is Crucial: Particle Accelerators: Steering and focusing charged particles using magnetic and electric fields. Mass Spectrometers: Separation of ions based on mass-to-charge ratio using magnetic deflection. Plasma Confinement Devices: Magnetic fields are used to confine hot plasma in fusion reactors like Tokamaks. Cathode Ray Tubes (CRTs): Electron beams are deflected using magnetic and electric fields. Role of Fields: Electric Fields ( \\( \\vec{E} \\) ) : Accelerate particles in the direction of the field. Magnetic Fields ( \\( \\vec{B} \\) ) : Cause circular or helical motion due to perpendicular force to velocity. 2. Simulating Particle Motion We simulate the motion of a charged particle under various field configurations using Newton\u2019s Second Law: \\[ m\\frac{d\\vec{v}}{dt} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: - \\( m \\) is the mass of the particle - \\( \\frac{d\\vec{v}}{dt} \\) is the particle\u2019s acceleration Scenarios: Uniform Magnetic Field Only: Particle undergoes circular or helical motion depending on velocity components. Radius of motion (Larmor radius) is: \\[ r = \\frac{mv_\\perp}{|q|B} \\] Combined Uniform Electric and Magnetic Fields: Results in drift motion or helical trajectories . If \\( \\vec{E} \\perp \\vec{B} \\) , particle drifts at: \\[ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] Crossed Fields ( \\( \\vec{E} \\perp \\vec{B} \\) ): The particle can exhibit complex motion with both circular and translational components. 3. Parameter Exploration The simulation will support variable parameters: Field Strengths: Electric field magnitude and direction \\( \\vec{E} \\) Magnetic field magnitude and direction \\( \\vec{B} \\) Particle Properties: Initial velocity \\( \\vec{v}_0 \\) Charge \\( q \\) Mass \\( m \\) By changing these, we observe different behaviors: Increasing \\( B \\) \u2192 smaller Larmor radius Increasing \\( E \\) \u2192 increased drift velocity Heavier mass \\( m \\) \u2192 slower response to field changes 4. Visualization We aim to produce labeled and annotated plots showing: 2D and 3D Trajectories : Top-down views for circular motion Side views for helical motion Key Physical Quantities : Larmor Radius ( \\( r \\) ) Drift Velocity ( \\( v_d \\) ) Visualizations provide intuition about the dynamics under different configurations and help relate abstract concepts to practical applications. 2D Simulation Magnetic Field B (T): Charge q (C): Mass m (kg): Initial Velocity vx (m/s): vy: Simulate 2D function simulate2D() { const canvas = document.getElementById(\"canvas2d\"); const ctx = canvas.getContext(\"2d\"); ctx.clearRect(0, 0, canvas.width, canvas.height); const B = parseFloat(document.getElementById(\"B2d\").value); const q = parseFloat(document.getElementById(\"q2d\").value); const m = parseFloat(document.getElementById(\"m2d\").value); const vx0 = parseFloat(document.getElementById(\"vx2d\").value); const vy0 = parseFloat(document.getElementById(\"vy2d\").value); let x = 250, y = 250; let vx = vx0, vy = vy0; const dt = 0.1; ctx.beginPath(); ctx.moveTo(x, y); for (let i = 0; i < 3000; i++) { const ax = (q / m) * vy * B; const ay = -(q / m) * vx * B; vx += ax * dt; vy += ay * dt; x += vx * dt; y += vy * dt; ctx.lineTo(x, y); } ctx.strokeStyle = \"blue\"; ctx.stroke(); } 3D Simulation Initial Velocity X: Y: Z: Simulate 3D function init3D() { const container = document.getElementById(\"canvas3d\"); container.innerHTML = \"\"; // temizle const scene = new THREE.Scene(); const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000); const renderer = new THREE.WebGLRenderer(); renderer.setSize(container.clientWidth, container.clientHeight); container.appendChild(renderer.domElement); const controls = new THREE.OrbitControls(camera, renderer.domElement); const q = 1, m = 1, B = new THREE.Vector3(0, 0, 1); let v = new THREE.Vector3( parseFloat(document.getElementById(\"vx3d\").value), parseFloat(document.getElementById(\"vy3d\").value), parseFloat(document.getElementById(\"vz3d\").value) ); let pos = new THREE.Vector3(0, 0, 0); const dt = 0.05; const geometry = new THREE.BufferGeometry(); const positions = []; for (let i = 0; i < 1000; i++) { const F = new THREE.Vector3().crossVectors(v, B).multiplyScalar(q / m); v.add(F.clone().multiplyScalar(dt)); pos.add(v.clone().multiplyScalar(dt)); positions.push(pos.x, pos.y, pos.z); } geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3)); const material = new THREE.LineBasicMaterial({ color: 0xff0000 }); const line = new THREE.Line(geometry, material); scene.add(line); scene.add(new THREE.AxesHelper(5)); camera.position.set(10, 10, 10); controls.update(); function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); } animate(); } Suggestions for Extensions Simulate non-uniform magnetic fields to model magnetic mirrors or advanced trap designs. Incorporate relativistic effects for particles approaching light speed. Add collision effects to simulate plasma interactions. References Griffiths, D. J. Introduction to Electrodynamics Jackson, J. D. Classical Electrodynamics Numerical Recipes in Python: Runge-Kutta Methods","title":"Electromagnetism: Lorentz Force Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#electromagnetism-lorentz-force-simulation","text":"","title":"Electromagnetism: Lorentz Force Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1-simulating-the-effects-of-the-lorentz-force","text":"","title":"Problem 1: Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force describes the combined effect of electric and magnetic fields on a moving charged particle. It is a cornerstone of electromagnetism and plays a crucial role in: Plasma physics Particle accelerators Mass spectrometry Astrophysical plasmas Fusion devices (e.g., Tokamaks) The Lorentz force is defined by the following vector equation: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: - \\( \\vec{F} \\) is the force experienced by the particle (in newtons) - \\( q \\) is the charge of the particle (in coulombs) - \\( \\vec{E} \\) is the electric field (in volts per meter) - \\( \\vec{v} \\) is the velocity of the particle (in meters per second) - \\( \\vec{B} \\) is the magnetic field (in teslas) Understanding the behavior of charged particles in various field configurations allows us to model and design devices used in modern physics and engineering.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-exploration-of-applications","text":"","title":"1. Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#real-world-systems-where-lorentz-force-is-crucial","text":"Particle Accelerators: Steering and focusing charged particles using magnetic and electric fields. Mass Spectrometers: Separation of ions based on mass-to-charge ratio using magnetic deflection. Plasma Confinement Devices: Magnetic fields are used to confine hot plasma in fusion reactors like Tokamaks. Cathode Ray Tubes (CRTs): Electron beams are deflected using magnetic and electric fields.","title":"Real-World Systems Where Lorentz Force is Crucial:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#role-of-fields","text":"Electric Fields ( \\( \\vec{E} \\) ) : Accelerate particles in the direction of the field. Magnetic Fields ( \\( \\vec{B} \\) ) : Cause circular or helical motion due to perpendicular force to velocity.","title":"Role of Fields:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-simulating-particle-motion","text":"We simulate the motion of a charged particle under various field configurations using Newton\u2019s Second Law: \\[ m\\frac{d\\vec{v}}{dt} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: - \\( m \\) is the mass of the particle - \\( \\frac{d\\vec{v}}{dt} \\) is the particle\u2019s acceleration","title":"2. Simulating Particle Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#scenarios","text":"Uniform Magnetic Field Only: Particle undergoes circular or helical motion depending on velocity components. Radius of motion (Larmor radius) is: \\[ r = \\frac{mv_\\perp}{|q|B} \\] Combined Uniform Electric and Magnetic Fields: Results in drift motion or helical trajectories . If \\( \\vec{E} \\perp \\vec{B} \\) , particle drifts at: \\[ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] Crossed Fields ( \\( \\vec{E} \\perp \\vec{B} \\) ): The particle can exhibit complex motion with both circular and translational components.","title":"Scenarios:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-parameter-exploration","text":"The simulation will support variable parameters: Field Strengths: Electric field magnitude and direction \\( \\vec{E} \\) Magnetic field magnitude and direction \\( \\vec{B} \\) Particle Properties: Initial velocity \\( \\vec{v}_0 \\) Charge \\( q \\) Mass \\( m \\) By changing these, we observe different behaviors: Increasing \\( B \\) \u2192 smaller Larmor radius Increasing \\( E \\) \u2192 increased drift velocity Heavier mass \\( m \\) \u2192 slower response to field changes","title":"3. Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-visualization","text":"We aim to produce labeled and annotated plots showing: 2D and 3D Trajectories : Top-down views for circular motion Side views for helical motion Key Physical Quantities : Larmor Radius ( \\( r \\) ) Drift Velocity ( \\( v_d \\) ) Visualizations provide intuition about the dynamics under different configurations and help relate abstract concepts to practical applications.","title":"4. Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2d-simulation","text":"Magnetic Field B (T): Charge q (C): Mass m (kg): Initial Velocity vx (m/s): vy: Simulate 2D function simulate2D() { const canvas = document.getElementById(\"canvas2d\"); const ctx = canvas.getContext(\"2d\"); ctx.clearRect(0, 0, canvas.width, canvas.height); const B = parseFloat(document.getElementById(\"B2d\").value); const q = parseFloat(document.getElementById(\"q2d\").value); const m = parseFloat(document.getElementById(\"m2d\").value); const vx0 = parseFloat(document.getElementById(\"vx2d\").value); const vy0 = parseFloat(document.getElementById(\"vy2d\").value); let x = 250, y = 250; let vx = vx0, vy = vy0; const dt = 0.1; ctx.beginPath(); ctx.moveTo(x, y); for (let i = 0; i < 3000; i++) { const ax = (q / m) * vy * B; const ay = -(q / m) * vx * B; vx += ax * dt; vy += ay * dt; x += vx * dt; y += vy * dt; ctx.lineTo(x, y); } ctx.strokeStyle = \"blue\"; ctx.stroke(); }","title":"2D Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3d-simulation","text":"Initial Velocity X: Y: Z: Simulate 3D function init3D() { const container = document.getElementById(\"canvas3d\"); container.innerHTML = \"\"; // temizle const scene = new THREE.Scene(); const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000); const renderer = new THREE.WebGLRenderer(); renderer.setSize(container.clientWidth, container.clientHeight); container.appendChild(renderer.domElement); const controls = new THREE.OrbitControls(camera, renderer.domElement); const q = 1, m = 1, B = new THREE.Vector3(0, 0, 1); let v = new THREE.Vector3( parseFloat(document.getElementById(\"vx3d\").value), parseFloat(document.getElementById(\"vy3d\").value), parseFloat(document.getElementById(\"vz3d\").value) ); let pos = new THREE.Vector3(0, 0, 0); const dt = 0.05; const geometry = new THREE.BufferGeometry(); const positions = []; for (let i = 0; i < 1000; i++) { const F = new THREE.Vector3().crossVectors(v, B).multiplyScalar(q / m); v.add(F.clone().multiplyScalar(dt)); pos.add(v.clone().multiplyScalar(dt)); positions.push(pos.x, pos.y, pos.z); } geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3)); const material = new THREE.LineBasicMaterial({ color: 0xff0000 }); const line = new THREE.Line(geometry, material); scene.add(line); scene.add(new THREE.AxesHelper(5)); camera.position.set(10, 10, 10); controls.update(); function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); } animate(); }","title":"3D Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#suggestions-for-extensions","text":"Simulate non-uniform magnetic fields to model magnetic mirrors or advanced trap designs. Incorporate relativistic effects for particles approaching light speed. Add collision effects to simulate plasma interactions.","title":"Suggestions for Extensions"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#references","text":"Griffiths, D. J. Introduction to Electrodynamics Jackson, J. D. Classical Electrodynamics Numerical Recipes in Python: Runge-Kutta Methods","title":"References"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}